<script>
  if (window.__DEGRAM_BOOT) window.__DEGRAM_BOOT.ok = true;
  let currentRetry = 0;
  const MAX_RETRIES = 3;
  const PRO_FALLBACK_MAX = 1; // flash / flash-lite only: after 3 fails, 1 last rescue with pro
  let proFallbackUsed = 0;
  let repairHistory = []; // [{attempt, model, error, code}]

  // History
  let pendingHistorySave = false;

  // Interactive Edits (SVG -> Mermaid)
  var interactiveEdits = {
    nodeLabels: Object.create(null),
  };
  var flowEdgeEdits = {
    addMode: false,
    from: null,
  };
  const RENDER_INFLIGHT_KEY = "diagram.render.inflight";
  let isRenderRunning = false;
  let queuedRenderAutoRepair = null;

  function syncFlowOnlyControls(codeOverride) {
    const codeEl = document.getElementById("mermaidCode");
    const code =
      typeof codeOverride === "string"
        ? codeOverride
        : codeEl
          ? codeEl.value || ""
          : "";
    const isFlow =
      typeof isFlowchartLike === "function" ? isFlowchartLike(code) : false;

    document.querySelectorAll("[data-flow-only]").forEach((el) => {
      el.classList.toggle("hidden", !isFlow);
    });

    if (!isFlow) {
      if (flowEdgeEdits && flowEdgeEdits.addMode) {
        flowEdgeEdits.addMode = false;
        flowEdgeEdits.from = null;
        const btn = document.getElementById("edgeModeBtn");
        if (btn) btn.setAttribute("aria-pressed", "false");
      }

      const paletteModal = document.getElementById("paletteModal");
      if (
        paletteModal &&
        !paletteModal.classList.contains("hidden") &&
        typeof closePalette === "function"
      )
        closePalette();
    }
  }

  let textEditResolve = null;
  function promptTextAsync(opts) {
    const modal = document.getElementById("textEditModal");
    const titleEl = document.getElementById("textEditTitle");
    const inputEl = document.getElementById("textEditInput");
    const hintEl = document.getElementById("textEditHint");
    if (!modal || !titleEl || !inputEl || !hintEl) return Promise.resolve(null);

    const o = opts && typeof opts === "object" ? opts : {};
    titleEl.textContent = String(o.title || "Edit");
    inputEl.value = String(o.value || "");
    inputEl.placeholder = String(o.placeholder || "");
    hintEl.textContent = String(o.hint || "");

    modal.classList.remove("hidden");
    modal.classList.add("flex");
    window.setTimeout(() => inputEl.focus(), 0);

    return new Promise((resolve) => {
      if (typeof textEditResolve === "function") {
        try {
          textEditResolve(null);
        } catch (e) { }
      }
      textEditResolve = resolve;
    });
  }
  function resolveTextEdit(value) {
    const modal = document.getElementById("textEditModal");
    const inputEl = document.getElementById("textEditInput");
    if (!modal || !inputEl) return;
    const v = value === "__SUBMIT__" ? inputEl.value : value;
    modal.classList.add("hidden");
    modal.classList.remove("flex");
    const resolve = textEditResolve;
    textEditResolve = null;
    if (typeof resolve === "function") resolve(v == null ? null : String(v));
  }

  // --- Image prompt (Gemini image generation) ---
  const IMAGE_STYLE_MODULES = {
    business: {
      name: "スタンダード・ビジネス",
      prompt:
        "Professional corporate tech infographic. Modern flat vector design with subtle shadows (Material Design). Clean white background, Royal Blue (#4285F4) accents. High readability, generous whitespace, balanced grid layout. Geometric nodes.",
    },
    manga: {
      name: "日本の漫画・劇画風",
      prompt:
        "Japanese manga style illustration. Black-and-white ink with screentones, strong contrast. Dynamic composition with panels and speed lines. Use speech bubbles ONLY for the main title. No small text.",
    },
    whiteboard: {
      name: "手書きホワイトボード",
      prompt:
        "Hand-drawn whiteboard sketch. Rough marker strokes, imperfect boxes, organic layout (Excalidraw style). Whiteboard background with black/blue/red marker ink. Casual brainstorming vibe.",
    },
    clay: {
      name: "クレイモーフィズム (3D)",
      prompt:
        "Cute 3D claymorphism infographic. Soft rounded clay-like objects, gentle lighting, soft shadows. Pastel palette (soft blue/pink/mint) on light background. Nodes look like tangible 3D buttons.",
    },
    cyberpunk: {
      name: "サイバーパンク",
      prompt:
        "Dark mode cyberpunk futuristic infographic. Deep navy/black background with glowing neon cyan/magenta lines. Holographic icons, subtle scanline effects. High-tech, sleek interface.",
    },
    minimal_mono: {
      name: "ミニマル・モノクロ",
      prompt:
        "Minimalist monochrome wireframe diagram. Thin black lines on pure white background. No shading, no gradients. Architecturally clean, swiss design typography style. Ultra-simple icons.",
    },
    isometric: {
      name: "アイソメトリック (2.5D)",
      prompt:
        "2.5D Isometric system diagram. Orthographic projection (30-degree angle). Floating platforms, servers, and blocks connected by piping or data streams. Tech blue and glass textures. Structural and organized.",
    },
    blueprint: {
      name: "設計図・青写真",
      prompt:
        "Technical blueprint style. White lines on a classic blue grid paper background. Engineering aesthetic, precise measurements, schematic icons. Looks like an architectural plan.",
    },
    paper_cutout: {
      name: "切り絵・ペーパークラフト",
      prompt:
        "Layered paper cutout art style. Elements look like stacked colored paper with drop shadows creating depth. Vibrant but soft colors. Texture of construction paper. Whimsical and crafty.",
    },
  };

  const IMAGE_STYLE_NEGATIVES = {
    business: "No hand-drawn style. No manga. No neon cyberpunk. No 3D clay.",
    manga:
      "No color. Monochrome only. No photorealism. No characters, no faces, no product photos, no cinematic scenes. No comic sound effects unless they appear verbatim in the Mermaid labels. No advertisement/poster composition.",
    whiteboard: "No clean perfect vector. No glossy 3D. No photorealism.",
    clay: "No flat 2D vector. No sharp edges. No photorealism.",
    cyberpunk: "No bright white background. No pastel cute style.",
    minimal_mono: "No shading. No gradients. No 3D. No color.",
    isometric: "No front-facing flat 2D. No hand-drawn style.",
    blueprint: "No colorful palette. No hand-drawn doodles. No 3D clay.",
    paper_cutout: "No photorealistic paper. No flat wireframe only.",
  };

  let imagePromptResolve = null;
  function promptImagePromptSettingsAsync() {
    const modal = document.getElementById("imagePromptModal");
    const langEl = document.getElementById("imageLangSelect");
    const selectEl = document.getElementById("imageStyleSelect");
    const customEl = document.getElementById("imageStyleCustomInput");
    const negEl = document.getElementById("imageNegativesInput");
    if (!modal || !langEl || !selectEl || !customEl || !negEl)
      return Promise.resolve(null);

    if (!selectEl.__degramPopulated) {
      for (const [id, v] of Object.entries(IMAGE_STYLE_MODULES)) {
        const opt = document.createElement("option");
        opt.value = id;
        opt.textContent = `${id} - ${v.name}`;
        selectEl.appendChild(opt);
      }
      selectEl.__degramPopulated = true;
    }

    const savedStyle =
      localStorage.getItem("diagram.imagePrompt.styleId") || "business";
    selectEl.value = IMAGE_STYLE_MODULES[savedStyle] ? savedStyle : "business";
    const savedLang =
      localStorage.getItem("diagram.imagePrompt.lang") || "auto";
    langEl.value =
      savedLang === "ja" || savedLang === "en" || savedLang === "auto"
        ? savedLang
        : "auto";
    customEl.value =
      localStorage.getItem("diagram.imagePrompt.custom." + selectEl.value) ||
      "";
    negEl.value = localStorage.getItem("diagram.imagePrompt.negatives") || "";

    selectEl.onchange = () => {
      try {
        localStorage.setItem("diagram.imagePrompt.styleId", selectEl.value);
        customEl.value =
          localStorage.getItem(
            "diagram.imagePrompt.custom." + selectEl.value
          ) || "";
      } catch (e) { }
    };

    modal.classList.remove("hidden");
    modal.classList.add("flex");
    window.setTimeout(() => (langEl || selectEl).focus(), 0);

    return new Promise((resolve) => {
      if (typeof imagePromptResolve === "function") {
        try {
          imagePromptResolve(null);
        } catch (e) { }
      }
      imagePromptResolve = resolve;
    });
  }

  function resolveImagePrompt(value) {
    const modal = document.getElementById("imagePromptModal");
    const langEl = document.getElementById("imageLangSelect");
    const selectEl = document.getElementById("imageStyleSelect");
    const customEl = document.getElementById("imageStyleCustomInput");
    const negEl = document.getElementById("imageNegativesInput");
    if (!modal || !langEl || !selectEl || !customEl || !negEl) return;

    const isSubmit = value === "__SUBMIT__";
    const payload = isSubmit
      ? {
        lang: String(langEl.value || "auto"),
        styleId: String(selectEl.value || "business"),
        styleCustom: String(customEl.value || ""),
        extraNegatives: String(negEl.value || ""),
      }
      : null;

    if (isSubmit) {
      try {
        localStorage.setItem("diagram.imagePrompt.lang", payload.lang);
        localStorage.setItem("diagram.imagePrompt.styleId", payload.styleId);
        localStorage.setItem(
          "diagram.imagePrompt.custom." + payload.styleId,
          payload.styleCustom
        );
        localStorage.setItem(
          "diagram.imagePrompt.negatives",
          payload.extraNegatives
        );
      } catch (e) { }
    }

    modal.classList.add("hidden");
    modal.classList.remove("flex");
    const resolve = imagePromptResolve;
    imagePromptResolve = null;
    if (typeof resolve === "function") resolve(payload);
  }
  function sanitizeInlineLabel(text) {
    let s = String(text == null ? "" : text);
    s = s.replace(/\uFEFF/g, "");
    s = s.replace(/\r/g, "");
    s = s.replace(/\n+/g, " ");
    s = s.replace(/\s+/g, " ").trim();
    s = s.replace(/\[/g, "［").replace(/\]/g, "］");
    s = s.replace(/</g, "＜").replace(/>/g, "＞");
    s = s.replace(/\\+\"/g, "'");
    s = s.replace(/"/g, "'");
    s = s.replace(/'/g, "’");
    if (s.length > 240) s = s.slice(0, 240);
    return s;
  }
  function getFlowchartNodeId(node) {
    if (!node) return "";
    const dataId = node.getAttribute && node.getAttribute("data-id");
    if (dataId) return String(dataId).trim();
    const idAttr = node.getAttribute ? node.getAttribute("id") || "" : "";
    if (idAttr) {
      const parts = String(idAttr).split(/[-_]/).filter(Boolean);
      for (let i = parts.length - 1; i >= 0; i--) {
        const p = parts[i];
        if (/^\d+$/.test(p)) continue;
        if (/^(flowchart|graph|node)$/i.test(p)) continue;
        if (/^[A-Za-z0-9_]+$/.test(p)) return p;
      }
    }
    const titleEl = node.querySelector ? node.querySelector("title") : null;
    const t =
      titleEl && titleEl.textContent ? String(titleEl.textContent).trim() : "";
    return /^[A-Za-z0-9_]+$/.test(t) ? t : "";
  }
  function toggleEdgeMode(force) {
    const next = typeof force === "boolean" ? force : !flowEdgeEdits.addMode;
    flowEdgeEdits.addMode = next;
    if (!next) flowEdgeEdits.from = null;
    const btn = document.getElementById("edgeModeBtn");
    if (btn) btn.setAttribute("aria-pressed", next ? "true" : "false");
    showToast(
      "info",
      next ? "エッジ追加モード：ノードを2つ選択" : "エッジ追加モード：OFF",
      { timeoutMs: 1800 }
    );
  }
  function normalizeFlowchartEdgeLabel(text) {
    let s = String(text == null ? "" : text).trim();
    if (!s) return "";
    s = s.replace(/\s+/g, " ");
    if (
      (s.length >= 2 && s[0] === '"' && s[s.length - 1] === '"') ||
      (s.length >= 2 && s[0] === "'" && s[s.length - 1] === "'")
    ) {
      s = s.slice(1, -1).trim();
    }
    return s;
  }
  function parseFlowchartEdgeLine(line) {
    const src = String(line || "");
    const id = "([A-Za-z0-9_.-]+)";
    const edgeEnd = "(?=$|\\s|[^A-Za-z0-9_.-])";
    const sourceDecoration =
      "(?:\\s*(?:\\[\\[[^\\]]*\\]\\]|\\(\\([^\\)]*\\)\\)|\\[[^\\]]*\\]|\\{[^\\}]*\\}|\\([^\\)]*\\)))?";

    let m = src.match(
      new RegExp(
        "^\\s*" +
        id +
        sourceDecoration +
        "\\s*(?:--+>|==+>|-\\.->)\\s*\\|([^|]*)\\|\\s*" +
        id +
        edgeEnd
      )
    );
    if (m) {
      return {
        from: m[1],
        to: m[3],
        label: normalizeFlowchartEdgeLabel(m[2]),
        rawLabel: String(m[2] || "").trim(),
      };
    }

    m = src.match(
      new RegExp(
        "^\\s*" + id + sourceDecoration + "\\s*--\\s*(.*?)\\s*-->\\s*" + id + edgeEnd
      )
    );
    if (m) {
      return {
        from: m[1],
        to: m[3],
        label: normalizeFlowchartEdgeLabel(m[2]),
        rawLabel: String(m[2] || "").trim(),
      };
    }

    m = src.match(
      new RegExp(
        "^\\s*" + id + sourceDecoration + "\\s*(?:--+>|==+>|-\\.->)\\s*" + id + edgeEnd
      )
    );
    if (m) {
      return {
        from: m[1],
        to: m[2],
        label: "",
        rawLabel: "",
      };
    }

    return null;
  }
  function findFlowchartEdgeLineIndex(lines, from, to, previousLabel) {
    const f = String(from || "").trim();
    const t = String(to || "").trim();
    if (!f || !t) return -1;

    const targetLabel = normalizeFlowchartEdgeLabel(previousLabel);
    const matches = [];
    for (let i = 0; i < lines.length; i++) {
      const parsed = parseFlowchartEdgeLine(lines[i]);
      if (!parsed) continue;
      if (parsed.from === f && parsed.to === t) {
        matches.push({ index: i, parsed });
      }
    }
    if (!matches.length) return -1;
    if (targetLabel) {
      for (let i = 0; i < matches.length; i++) {
        if (matches[i].parsed.label === targetLabel) return matches[i].index;
      }
    }
    if (matches.length === 1) return matches[0].index;
    if (!targetLabel) {
      for (let i = 0; i < matches.length; i++) {
        if (!matches[i].parsed.label) return matches[i].index;
      }
    }
    return matches[0].index;
  }
  function upsertFlowchartEdge(code, from, to, label, previousLabel) {
    const f = String(from || "").trim();
    const t = String(to || "").trim();
    if (!f || !t) return code;
    const lbl = sanitizeInlineLabel(label || "");
    const newLine = lbl
      ? f + " -->|" + lbl.replace(/\|/g, " ") + "| " + t
      : f + " --> " + t;

    const lines = String(code || "").split(/\r?\n/);
    const idx = findFlowchartEdgeLineIndex(lines, f, t, previousLabel);
    if (idx >= 0) {
      const indent = (lines[idx].match(/^\s*/) || [""])[0];
      lines[idx] = indent + newLine;
      return lines.join("\n");
    }
    lines.push(newLine);
    return lines.join("\n");
  }
  function parseFlowchartEdgesFromCode(code) {
    const lines = String(code || "").split(/\r?\n/);
    const edges = [];
    for (let i = 0; i < lines.length; i++) {
      const line = String(lines[i] || "");
      const parsed = parseFlowchartEdgeLine(line);
      if (!parsed) continue;
      edges.push({
        from: parsed.from,
        to: parsed.to,
        label: parsed.label,
        rawLabel: parsed.rawLabel,
        lineIndex: i,
        raw: line,
      });
    }
    return edges;
  }
  function findEdgeByUniqueLabel(code, labelText) {
    const target = normalizeFlowchartEdgeLabel(labelText);
    if (!target) return null;
    const edges = parseFlowchartEdgesFromCode(code).filter(
      (e) => normalizeFlowchartEdgeLabel(e.label) === target
    );
    if (edges.length === 1) return { from: edges[0].from, to: edges[0].to };
    return null;
  }
  function removeFlowchartEdge(code, from, to, previousLabel) {
    const f = String(from || "").trim();
    const t = String(to || "").trim();
    if (!f || !t) return { code: String(code || ""), removed: false };
    const lines = String(code || "").split(/\r?\n/);
    const idx = findFlowchartEdgeLineIndex(lines, f, t, previousLabel);
    if (idx < 0) return { code: lines.join("\n"), removed: false };
    lines.splice(idx, 1);
    return { code: lines.join("\n"), removed: true };
  }
  function extractFlowchartEdgeEndpointsFromText(text) {
    const s = String(text || "").trim();
    if (!s) return null;

    let m = s.match(
      /(?:^|[\s,;])LS[-_]?([A-Za-z0-9_.-]+)(?:[\s,;].*?)LE[-_]?([A-Za-z0-9_.-]+)(?:$|[\s,;])/i
    );
    if (m) return { from: m[1], to: m[2] };

    m = s.match(
      /(?:^|[\s,;])LE[-_]?([A-Za-z0-9_.-]+)(?:[\s,;].*?)LS[-_]?([A-Za-z0-9_.-]+)(?:$|[\s,;])/i
    );
    if (m) return { from: m[2], to: m[1] };

    m = s.match(
      /(?:^|[^A-Za-z0-9_.-])L[-_]+([A-Za-z0-9_.]+)[-_]+([A-Za-z0-9_.]+)(?:[-_]+\d+)?(?:$|[^A-Za-z0-9_.-])/i
    );
    if (m) return { from: m[1], to: m[2] };

    m = s.match(/\b([A-Za-z0-9_.-]+)\b\s*[-.]*-+>?\s*\b([A-Za-z0-9_.-]+)\b/);
    if (m) return { from: m[1], to: m[2] };

    return null;
  }
  function getFlowchartEdgeEndpointsFromSvg(el, code) {
    if (!el || !el.closest) return null;
    const edgeGroup = el.closest("g.edgePath") || el.closest("g.edgeLabel");
    if (!edgeGroup) return null;

    const candidates = [];
    const pushCandidate = (v) => {
      const s = String(v || "").trim();
      if (!s) return;
      candidates.push(s);
    };

    let cur = edgeGroup;
    for (let depth = 0; cur && depth < 4; depth++) {
      if (cur.getAttribute) {
        pushCandidate(cur.getAttribute("id"));
        pushCandidate(cur.getAttribute("class"));
        pushCandidate(cur.getAttribute("data-id"));
      }
      const tEl = cur.querySelector ? cur.querySelector("title") : null;
      if (tEl && tEl.textContent) pushCandidate(tEl.textContent);
      cur = cur.parentElement;
    }

    const path = edgeGroup.querySelector ? edgeGroup.querySelector("path") : null;
    if (path && path.getAttribute) {
      pushCandidate(path.getAttribute("id"));
      pushCandidate(path.getAttribute("class"));
    }

    for (let i = 0; i < candidates.length; i++) {
      const ep = extractFlowchartEdgeEndpointsFromText(candidates[i]);
      if (ep) return ep;
    }

    // Fallback 1: edge label text uniquely maps to one edge in code.
    const labelTextEl = edgeGroup.querySelector ? edgeGroup.querySelector("text") : null;
    const labelText =
      labelTextEl && labelTextEl.textContent
        ? String(labelTextEl.textContent).trim()
        : "";
    if (code) {
      const byLabel = findEdgeByUniqueLabel(code, labelText);
      if (byLabel) return byLabel;
    }

    // Fallback 2: map clicked edge visual order to parsed edge order.
    if (code) {
      const allEdges = parseFlowchartEdgesFromCode(code);
      if (allEdges.length) {
        const output = document.getElementById("diagram-output");
        if (output) {
          const isPath = edgeGroup.classList && edgeGroup.classList.contains("edgePath");
          const selector = isPath ? "g.edgePath" : "g.edgeLabel";
          const groups = Array.prototype.slice.call(output.querySelectorAll(selector));
          const edges = isPath
            ? allEdges
            : allEdges.filter((e) => String(e.label || "").trim() !== "");
          const idx = groups.indexOf(edgeGroup);
          if (idx >= 0 && idx < edges.length) {
            return { from: edges[idx].from, to: edges[idx].to };
          }
        }
      }
    }

    // Fallback 3: for edgeLabel clicks, map to edgePath by visual index and parse edgePath tokens.
    if (code && edgeGroup.classList && edgeGroup.classList.contains("edgeLabel")) {
      const output = document.getElementById("diagram-output");
      if (output) {
        const labelGroups = Array.prototype.slice.call(
          output.querySelectorAll("g.edgeLabel")
        );
        const edgePaths = Array.prototype.slice.call(
          output.querySelectorAll("g.edgePath")
        );
        const idx = labelGroups.indexOf(edgeGroup);
        if (idx >= 0 && idx < edgePaths.length) {
          const gp = edgePaths[idx];
          const items = [];
          if (gp && gp.getAttribute) {
            items.push(gp.getAttribute("id") || "");
            items.push(gp.getAttribute("class") || "");
            items.push(gp.getAttribute("data-id") || "");
          }
          const p = gp && gp.querySelector ? gp.querySelector("path") : null;
          if (p && p.getAttribute) {
            items.push(p.getAttribute("id") || "");
            items.push(p.getAttribute("class") || "");
          }
          for (let i = 0; i < items.length; i++) {
            const ep = extractFlowchartEdgeEndpointsFromText(items[i]);
            if (ep) return ep;
          }
        }
      }
    }

    try {
      console.warn("[EdgeResolve] failed to resolve endpoints", {
        candidates,
        labelText,
        parsedEdgeCount: code ? parseFlowchartEdgesFromCode(code).length : 0,
      });
    } catch (_) { }

    return null;
  }

  // File Upload Variable
  let currentFile = null; // { mimeType, data, filename }

  // Pan & Zoom
  let scale = 1;
  let pointX = 0;
  let pointY = 0;
  let isPanning = false;
  let startX = 0;
  let startY = 0;
  let initialPinchDistance = null;
  let lastScale = 1;
  let pinchWorldX = 0;
  let pinchWorldY = 0;
  const MIN_SCALE = 0.2;
  const MAX_SCALE = 6;

  // --- App State (empty → ready → generating → success / error) ---
  const APP_STATE = Object.freeze({
    empty: "empty",
    ready: "ready",
    generating: "generating",
    success: "success",
    error: "error",
  });
  let appState = APP_STATE.empty;

  function isPanelOpenForLayout(panelEl, desktop) {
    if (!panelEl) return false;
    if (
      panelEl.classList.contains("opacity-0") ||
      panelEl.classList.contains("pointer-events-none")
    )
      return false;
    const style = getComputedStyle(panelEl);
    if (desktop) return (parseFloat(style.width) || 0) > 8;
    const transform = style.transform || "";
    if (!transform || transform === "none") return true;
    const m = transform.match(/^matrix\(([^)]+)\)$/);
    if (m) {
      const parts = m[1].split(",").map((v) => parseFloat(v.trim()));
      const tx = parts.length >= 6 ? parts[4] : 0;
      return !(Number.isFinite(tx) && tx < -1);
    }
    return true;
  }

  function updateFloatingDockVisibility(forceEmptyStateVisible) {
    const dock = document.getElementById("floatingDock");
    if (!dock) return;
    const isDesktop = window.innerWidth >= 768;
    const panel = document.getElementById("sidePanel");
    const panelOpen = isPanelOpenForLayout(panel, isDesktop);
    const output = document.getElementById("diagram-output");
    const noDiagram = !output || output.classList.contains("opacity-0");
    const emptyVisible =
      typeof forceEmptyStateVisible === "boolean"
        ? forceEmptyStateVisible
        : appState === APP_STATE.empty && noDiagram;
    const hide = emptyVisible || (!isDesktop && panelOpen);
    dock.classList.toggle("hidden", hide);
  }

  function getIsReady() {
    const input =
      document.getElementById("userInput") &&
        document.getElementById("userInput").value
        ? document.getElementById("userInput").value.trim()
        : "";
    return !!input || !!currentFile;
  }
  function setFormDisabled(disabled) {
    const els = [
      document.getElementById("userInput"),
      document.getElementById("diagramTypeSelect"),
      document.getElementById("fileInput"),
      document.getElementById("fileAttachBtn"),
      document.getElementById("generateBtn"),
      document.getElementById("mermaidCode"),
    ].filter(Boolean);
    els.forEach((el) => {
      if (el.id === "generateBtn") return;
      el.disabled = !!disabled;
    });
    document.querySelectorAll("[data-side-tab]").forEach((btn) => {
      btn.disabled = !!disabled;
    });
  }
  function flashGenerateBtn(kind) {
    const btn = document.getElementById("generateBtn");
    if (!btn) return;
    const cls = kind === "success" ? "btn-flash-success" : "btn-flash-error";
    btn.classList.remove("btn-flash-success", "btn-flash-error");
    btn.classList.add(cls);
    window.setTimeout(() => btn.classList.remove(cls), 720);
  }
  function syncGenerateButton() {
    const btn = document.getElementById("generateBtn");
    if (!btn) return;
    const spinner = document.getElementById("generateSpinner");
    const icon = document.getElementById("generateIcon");
    const text = document.getElementById("generateText");
    const labelGenerate = typeof t === "function" ? t("generate") : "Generate";
    const labelThinking =
      typeof t === "function" ? t("thinking") : "Thinking...";
    const labelPromptNeeded =
      typeof t === "function" ? t("promptNeeded") : "Enter a prompt";

    if (appState === APP_STATE.generating) {
      btn.disabled = true;
      btn.setAttribute("aria-busy", "true");
      if (spinner) spinner.classList.remove("hidden");
      if (icon) icon.classList.add("hidden");
      if (text) text.textContent = labelThinking;
      btn.title = "";
      return;
    }

    btn.setAttribute("aria-busy", "false");
    if (spinner) spinner.classList.add("hidden");
    if (icon) icon.classList.remove("hidden");

    const ready = getIsReady();
    btn.disabled = !ready;
    if (!ready) {
      if (text) text.textContent = labelGenerate;
      btn.title = labelPromptNeeded;
    } else {
      btn.title = "";
      if (text) text.textContent = labelGenerate;
    }
  }
  function syncEmptyStateCard() {
    const card = document.getElementById("emptyStateCard");
    if (!card) return;
    const output = document.getElementById("diagram-output");
    const noDiagram = !output || output.classList.contains("opacity-0");
    const show = appState === APP_STATE.empty && noDiagram;
    card.classList.toggle("hidden", !show);
    updateFloatingDockVisibility(show);
  }
  function setAppState(next, payload) {
    const allowed = new Set(Object.values(APP_STATE));
    const target = allowed.has(next) ? next : APP_STATE.ready;
    appState = target;
    setFormDisabled(target === APP_STATE.generating);
    syncGenerateButton();
    syncEmptyStateCard();
    if (target === APP_STATE.success) {
      flashGenerateBtn("success");
      showToast(
        "success",
        payload && payload.message
          ? payload.message
          : typeof t === "function"
            ? t("generated")
            : "Generated"
      );
      window.setTimeout(() => {
        if (appState === APP_STATE.success)
          setAppState(getIsReady() ? APP_STATE.ready : APP_STATE.empty);
      }, 650);
    }
    if (target === APP_STATE.error) {
      flashGenerateBtn("error");
      if (payload && payload.message) {
        if (payload.sticky) showCanvasError(payload.message);
        else showToast("error", payload.message);
      }
      window.setTimeout(() => {
        if (appState === APP_STATE.error)
          setAppState(getIsReady() ? APP_STATE.ready : APP_STATE.empty);
      }, 650);
    }
  }
  function syncAppStateFromInputs() {
    if (appState === APP_STATE.generating) return;
    setAppState(getIsReady() ? APP_STATE.ready : APP_STATE.empty);
  }

  window.onload = function () {
    let skipAutoRenderOnBoot = false;
    try {
      // If previous page was reloaded while rendering, avoid immediate auto-render loop.
      if (sessionStorage.getItem(RENDER_INFLIGHT_KEY) === "1") {
        skipAutoRenderOnBoot = true;
      }
      sessionStorage.removeItem(RENDER_INFLIGHT_KEY);
    } catch (_) { }

    if (typeof mermaid !== "undefined") {
      mermaid.initialize({
        startOnLoad: false,
        securityLevel: "loose",
        theme: "dark",
      });
    } else {
      showToast("error", "ライブラリの読み込みに失敗しました。");
    }
    setupPanZoom();
    setupPanelResize();
    loadUiPrefs();
    changeTheme({ skipRender: skipAutoRenderOnBoot });
    if (skipAutoRenderOnBoot) {
      showToast(
        "info",
        "前回の描画処理が中断されたため、起動時の自動プレビューをスキップしました。"
      );
    }
    handleResize();
    refreshHistory();
    syncAppStateFromInputs();
    updateFloatingDockVisibility();

    const inputEl = document.getElementById("userInput");
    if (inputEl) {
      inputEl.addEventListener("input", () => syncAppStateFromInputs());
      inputEl.addEventListener("paste", (e) => handlePaste(e));
    }

    const codeEl = document.getElementById("mermaidCode");
    if (codeEl)
      codeEl.addEventListener("input", () =>
        syncFlowOnlyControls(codeEl.value || "")
      );

    document.addEventListener("keydown", (e) => {
      if (!e) return;
      if ((e.ctrlKey || e.metaKey) && e.key === "Enter") {
        const editModal = document.getElementById("textEditModal");
        if (editModal && !editModal.classList.contains("hidden")) {
          e.preventDefault();
          resolveTextEdit("__SUBMIT__");
          return;
        }
        e.preventDefault();
        if (appState !== APP_STATE.generating) startGeneration();
      }
      if (e.key === "Escape") {
        closeDownloadMenu();
        if (
          document.getElementById("typeHelpModal") &&
          !document.getElementById("typeHelpModal").classList.contains("hidden")
        )
          closeTypeHelp();
        if (
          document.getElementById("paletteModal") &&
          !document.getElementById("paletteModal").classList.contains("hidden")
        )
          closePalette();
        if (
          document.getElementById("settingsModal") &&
          !document.getElementById("settingsModal").classList.contains("hidden")
        )
          closeSettings();
        if (
          document.getElementById("confirmModal") &&
          !document.getElementById("confirmModal").classList.contains("hidden")
        )
          resolveConfirm(false);
        if (
          document.getElementById("textEditModal") &&
          !document.getElementById("textEditModal").classList.contains("hidden")
        )
          resolveTextEdit(null);
        togglePanel(false);
      }
    });

    syncFlowOnlyControls();
  };

  // --- File Handling Functions ---
  function handleFileSelect(input) {
    const file = input.files[0];
    if (!file) return;
    processFile(file);
    input.value = ""; // Reset for same file selection
  }

  function processFile(file) {
    if (!file) return;

    // Size check (10MB warning for GAS payload safety)
    if (file.size > 10 * 1024 * 1024) {
      showToast(
        "info",
        "ファイルサイズが大きすぎます (10MB以下推奨)。GASの制限によりエラーになる可能性があります。",
        { timeoutMs: 5200 }
      );
    }

    const reader = new FileReader();
    reader.onload = function (e) {
      const base64String = e.target.result;
      const delimiterIndex = base64String.indexOf(",");
      const contentType = base64String
        .substring(5, delimiterIndex)
        .replace(";base64", "");
      const rawBase64 = base64String.substring(delimiterIndex + 1);

      currentFile = {
        mimeType: contentType,
        data: rawBase64,
        filename: file.name || "clipboard-data",
      };

      updateFileUI();
      syncAppStateFromInputs();
    };
    reader.readAsDataURL(file);
  }

  function handlePaste(e) {
    const items = (e.clipboardData || e.originalEvent.clipboardData).items;
    for (let i = 0; i < items.length; i++) {
      if (items[i].kind === 'file') {
        const file = items[i].getAsFile();
        if (file) {
          processFile(file);
          // Optional: Prevent default if we want to stop text paste when a file is pasted
          // However, usually we want to allow text paste too if it contains text.
          // In most browsers, if you copy a file, it's just a file.
        }
      }
    }
  }

  function clearFile() {
    currentFile = null;
    document.getElementById("fileInput").value = "";
    updateFileUI();
    syncAppStateFromInputs();
  }

  function updateFileUI() {
    const chip = document.getElementById("fileChip");
    const nameDisplay = document.getElementById("fileNameDisplay");

    if (currentFile) {
      nameDisplay.textContent = currentFile.filename;
      chip.classList.remove("hidden");
    } else {
      chip.classList.add("hidden");
    }
  }

  function clearPrompt() {
    document.getElementById("userInput").value = "";
    syncAppStateFromInputs();
  }

  function clearCode() {
    document.getElementById("mermaidCode").value = "";
    const outputDiv = document.getElementById("diagram-output");
    outputDiv.innerHTML = "";
    outputDiv.classList.add("opacity-0");
    clearCanvasError();
    resetZoom();
    syncAppStateFromInputs();
  }

  function newDiagram() {
    clearPrompt();
    clearFile();
    clearCode();
  }

  // --- UI Prefs ---
  const PANEL_WIDTH_KEY = "diagram.sidePanelWidth";
  const LAYOUT_KEY = "diagram.layoutMode";
  const DIAGRAM_THEME_KEY = "diagram.diagramTheme";
  const UI_THEME_KEY = "diagram.uiTheme";
  const UI_LANG_KEY = "diagram.uiLang";
  const FONT_SIZE_KEY = "diagram.fontSize";
  const PALETTE_NODE_KEY = "diagram.palette.node";
  const PALETTE_EDGE_KEY = "diagram.palette.edge";
  const SIDE_TAB_KEY = "diagram.sideTab";
  function normalizeDiagramTheme(theme) {
    const raw = (theme || "").toString().trim().toLowerCase();
    if (raw === "default") return "default";
    if (raw === "neutral" || raw === "monochrome") return "default";
    if (raw === "forest" || raw === "wood") return "dark";
    if (raw === "neon") return "dark";
    if (raw === "dark") return "dark";
    if (raw === "light") return "default";
    return raw;
  }
  function getDiagramTheme() {
    const raw = localStorage.getItem(DIAGRAM_THEME_KEY) || "dark";
    const next = normalizeDiagramTheme(raw);
    const allowed = new Set(["dark", "default"]);
    return allowed.has(next) ? next : "dark";
  }
  function getStoredPanelWidth() {
    const raw = localStorage.getItem(PANEL_WIDTH_KEY);
    const parsed = raw ? Number(raw) : NaN;
    const fallback = 340;
    const value = Number.isFinite(parsed) ? parsed : fallback;
    const min = 260;
    const max = Math.max(min, Math.min(720, window.innerWidth - 220));
    return Math.max(min, Math.min(max, value));
  }
  function setStoredPanelWidth(width) {
    const clamped = Math.round(width);
    localStorage.setItem(PANEL_WIDTH_KEY, String(clamped));
  }
  function getLayoutMode() {
    const raw = localStorage.getItem(LAYOUT_KEY) || "td";
    if (raw === "auto") return "td";
    return raw === "lr" || raw === "td" ? raw : "td";
  }
  function setLayoutMode(mode) {
    const next = mode === "lr" || mode === "td" ? mode : "td";
    localStorage.setItem(LAYOUT_KEY, next);
  }
  function loadUiPrefs() {
    const layout = getLayoutMode();
    updateLayoutButtons(layout);

    updateThemeChips(getDiagramTheme());

    const uiTheme = localStorage.getItem(UI_THEME_KEY) || "dark";
    setUiTheme(uiTheme === "light" ? "light" : "dark");
    syncUiThemeButtons();

    const lang = localStorage.getItem(UI_LANG_KEY) || "ja";
    setLanguage(lang === "en" ? "en" : "ja");
    syncLanguageButtons();

    applyFontSize(getFontSize());
    syncFontSizeButtons();

    const node = localStorage.getItem(PALETTE_NODE_KEY) || "#60a5fa";
    const edge = localStorage.getItem(PALETTE_EDGE_KEY) || "#94a3b8";
    const nodeInput = document.getElementById("nodeColorInput");
    const edgeInput = document.getElementById("edgeColorInput");
    if (nodeInput) nodeInput.value = node;
    if (edgeInput) edgeInput.value = edge;
    renderPalettePresets();

    setSideTab(localStorage.getItem(SIDE_TAB_KEY) || "create", {
      store: false,
    });
    updateApiKeyStatusUI();
  }

  function getFontSize() {
    const raw = (localStorage.getItem(FONT_SIZE_KEY) || "md").toString();
    return raw === "sm" || raw === "md" || raw === "lg" ? raw : "md";
  }
  function applyFontSize(size) {
    const next = size === "sm" || size === "lg" ? size : "md";
    const px = next === "sm" ? 14 : next === "lg" ? 18 : 16;
    document.documentElement.style.fontSize = String(px) + "px";
    document.body.setAttribute("data-font-size", next);
  }
  function setFontSizeAndSync(size) {
    const next = size === "sm" || size === "lg" ? size : "md";
    localStorage.setItem(FONT_SIZE_KEY, next);
    applyFontSize(next);
    syncFontSizeButtons();
  }
  function syncFontSizeButtons() {
    const current = getFontSize();
    document.querySelectorAll("[data-font-size]").forEach((btn) => {
      const active = btn.getAttribute("data-font-size") === current;
      btn.setAttribute("aria-pressed", active ? "true" : "false");
    });
  }

  function setSideTab(tab, opts) {
    const allowed = new Set(["create", "editor", "history"]);
    const current = allowed.has(tab) ? tab : "create";
    const store = !(opts && opts.store === false);
    if (store) localStorage.setItem(SIDE_TAB_KEY, current);

    document.querySelectorAll("[data-side-panel]").forEach((panel) => {
      panel.classList.toggle(
        "hidden",
        panel.getAttribute("data-side-panel") !== current
      );
    });
    document.querySelectorAll("[data-side-tab]").forEach((btn) => {
      const active = btn.getAttribute("data-side-tab") === current;
      btn.setAttribute("aria-pressed", active ? "true" : "false");
    });

    if (current === "create") {
      const input = document.getElementById("userInput");
      if (input && window.innerWidth >= 768)
        window.setTimeout(() => input.focus(), 0);
    }
    if (current === "editor") {
      const code = document.getElementById("mermaidCode");
      if (code && window.innerWidth >= 768)
        window.setTimeout(() => code.focus(), 0);
    }
  }

  function setDiagramThemeAndSync(theme) {
    const allowed = new Set(["dark", "default"]);
    const next = allowed.has(theme) ? theme : "dark";
    localStorage.setItem(DIAGRAM_THEME_KEY, next);
    updateThemeChips(next);
    changeTheme();
  }
  function updateThemeChips(theme) {
    const allowed = new Set(["dark", "default"]);
    const normalized = normalizeDiagramTheme(theme);
    const current = allowed.has(normalized) ? normalized : getDiagramTheme();
    document.querySelectorAll("[data-diagram-theme]").forEach((btn) => {
      const active = btn.getAttribute("data-diagram-theme") === current;
      btn.setAttribute("aria-pressed", active ? "true" : "false");
    });
  }
  function updateLayoutButtons(mode) {
    const current = mode === "lr" || mode === "td" ? mode : getLayoutMode();
    const btn = document.getElementById("layoutToggleBtn");
    const icon = document.getElementById("layoutToggleIcon");
    if (!btn || !icon) return;
    const isTd = current === "td";
    icon.textContent = isTd ? "swap_vert" : "swap_horiz";
    btn.title = isTd ? "レイアウト：縦" : "レイアウト：横";
    btn.setAttribute("aria-label", btn.title);
  }
  function toggleLayoutAndRender() {
    const current = getLayoutMode();
    const next = current === "lr" ? "td" : "lr";
    setLayoutMode(next);
    updateLayoutButtons(next);
    if (document.getElementById("mermaidCode").value) renderDiagram();
  }
  function setupPanelResize() {
    const panel = document.getElementById("sidePanel");
    const resizer = document.getElementById("panelResizer");
    if (!panel || !resizer) return;

    let isResizing = false;
    let startX = 0;
    let startWidth = 0;

    function onMove(e) {
      if (!isResizing) return;
      e.preventDefault();
      const dx = e.clientX - startX;
      const next = startWidth + dx;
      const min = 260;
      const max = Math.max(min, Math.min(720, window.innerWidth - 220));
      const width = Math.max(min, Math.min(max, next));
      panel.style.width = width + "px";
      setStoredPanelWidth(width);
    }
    function onUp() {
      if (!isResizing) return;
      isResizing = false;
      document.body.style.userSelect = "";
      document.body.style.cursor = "";
      window.removeEventListener("mousemove", onMove);
      window.removeEventListener("mouseup", onUp);
    }

    resizer.addEventListener("mousedown", (e) => {
      if (window.innerWidth < 768) return;
      const isClosed =
        panel.classList.contains("opacity-0") ||
        parseFloat(getComputedStyle(panel).width) === 0;
      if (isClosed) return;
      isResizing = true;
      startX = e.clientX;
      startWidth =
        parseFloat(getComputedStyle(panel).width) || getStoredPanelWidth();
      document.body.style.userSelect = "none";
      document.body.style.cursor = "col-resize";
      window.addEventListener("mousemove", onMove);
      window.addEventListener("mouseup", onUp);
    });
  }

  // --- Panel Logic ---
  function syncPanelMenuState(menuBtn, menuIcon, isOpen) {
    if (menuBtn)
      menuBtn.setAttribute("aria-expanded", isOpen ? "true" : "false");
    if (menuIcon) menuIcon.classList.toggle("-rotate-90", !!isOpen);
  }

  function setOpenPanelButtonVisible(openPanelBtn, visible) {
    if (!openPanelBtn) return;
    if (visible) {
      openPanelBtn.classList.remove("hidden");
      openPanelBtn.classList.add("flex");
    } else {
      openPanelBtn.classList.add("hidden");
      openPanelBtn.classList.remove("flex");
    }
  }

  function togglePanel(open) {
    const panel = document.getElementById("sidePanel");
    const btn = document.getElementById("openPanelBtn");
    const menuBtn = document.getElementById("panelToggleBtn");
    const menuIcon = document.getElementById("panelToggleIcon");
    const floatingDock = document.getElementById("floatingDock");
    const isDesktop = window.innerWidth >= 768;
    const isCurrentlyOpen = isPanelOpenForLayout(panel, isDesktop);
    const nextOpen = typeof open === "boolean" ? open : !isCurrentlyOpen;

    if (nextOpen) {
      panel.classList.remove("opacity-0", "pointer-events-none");
      if (isDesktop) {
        panel.classList.remove("fixed", "inset-0");
        panel.style.height = "";
        panel.style.transform = "";
        panel.style.width = getStoredPanelWidth() + "px";
      } else {
        panel.classList.add("fixed", "inset-0");
        panel.style.width = "";
        panel.style.height = "100vh";
        panel.style.transform = "translateX(0)";
      }
      setOpenPanelButtonVisible(btn, false);
      syncPanelMenuState(menuBtn, menuIcon, true);
    } else {
      if (isDesktop) {
        panel.classList.remove("fixed", "inset-0");
        panel.style.height = "";
        panel.style.transform = "";
        panel.style.width = "0px";
      } else {
        panel.classList.add("fixed", "inset-0");
        panel.style.width = "";
        panel.style.height = "100vh";
        panel.style.transform = "translateX(-100%)";
      }
      panel.classList.add("opacity-0", "pointer-events-none");
      setOpenPanelButtonVisible(btn, isDesktop);
      syncPanelMenuState(menuBtn, menuIcon, false);
    }

    updateFloatingDockVisibility();
  }

  function handleResize() {
    const panel = document.getElementById("sidePanel");
    const btn = document.getElementById("openPanelBtn");
    const menuBtn = document.getElementById("panelToggleBtn");
    const menuIcon = document.getElementById("panelToggleIcon");
    const floatingDock = document.getElementById("floatingDock");
    const isDesktop = window.innerWidth >= 768;
    if (!panel) return;
    if (!isDesktop) {
      // Mobile: keep current open/close state (avoid closing on virtual keyboard resize).
      const wantsOpen =
        menuBtn && menuBtn.getAttribute("aria-expanded") === "true";
      panel.classList.add("fixed", "inset-0");
      panel.style.width = "";
      panel.style.height = "100vh";
      setOpenPanelButtonVisible(btn, false);
      if (wantsOpen) {
        panel.style.transform = "translateX(0)";
        panel.classList.remove("opacity-0", "pointer-events-none");
        syncPanelMenuState(menuBtn, menuIcon, true);
      } else {
        panel.style.transform = "translateX(-100%)";
        panel.classList.add("opacity-0", "pointer-events-none");
        syncPanelMenuState(menuBtn, menuIcon, false);
      }
      updateFloatingDockVisibility();
      return;
    }

    panel.classList.remove("fixed", "inset-0");
    panel.style.height = "";
    panel.style.transform = "";
    const style = getComputedStyle(panel);
    const isOpen =
      !panel.classList.contains("opacity-0") &&
      !panel.classList.contains("pointer-events-none") &&
      parseFloat(style.width) > 8;
    if (isOpen) {
      panel.style.width = getStoredPanelWidth() + "px";
      panel.classList.remove("opacity-0", "pointer-events-none");
      setOpenPanelButtonVisible(btn, false);
    } else {
      panel.style.width = "0px";
      panel.classList.add("opacity-0", "pointer-events-none");
      setOpenPanelButtonVisible(btn, true);
    }
    syncPanelMenuState(menuBtn, menuIcon, false);
    // Auto layout removed; keep current direction on resize.
    updateFloatingDockVisibility();
  }
  let resizeTimer;
  window.addEventListener("resize", () => {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(handleResize, 100);
  });

  // --- Toast / Confirm (no alert/confirm) ---
  function showToast(kind, message, opts) {
    const host = document.getElementById("toastHost");
    if (!host) return;
    const type =
      kind === "success" || kind === "error" || kind === "info" ? kind : "info";
    const icon =
      type === "success" ? "check_circle" : type === "error" ? "error" : "info";
    const timeout =
      opts && Number.isFinite(opts.timeoutMs)
        ? opts.timeoutMs
        : type === "error"
          ? 5200
          : 3200;

    const el = document.createElement("div");
    el.className =
      "toast toast-" +
      type +
      " ui-surface rounded-xl shadow-2xl px-3 py-2 flex items-start gap-2 pointer-events-auto";
    el.innerHTML =
      '<span class="material-symbols-outlined text-lg mt-0.5">' +
      icon +
      "</span>" +
      '<div class="min-w-0 flex-1">' +
      '<div class="text-xs font-bold tracking-wide">' +
      (type === "success" ? "SUCCESS" : type === "error" ? "ERROR" : "INFO") +
      "</div>" +
      '<div class="text-sm ui-muted break-words leading-relaxed">' +
      escapeHtml(String(message || "")) +
      "</div>" +
      "</div>" +
      '<button type="button" class="canvas-glass canvas-control p-1 rounded-lg transition shadow" title="Close">' +
      '<span class="material-symbols-outlined text-lg">close</span>' +
      "</button>";

    const closeBtn = el.querySelector("button");
    if (closeBtn) closeBtn.addEventListener("click", () => el.remove());
    host.appendChild(el);

    if (timeout > 0) {
      window.setTimeout(() => {
        if (el && el.parentNode) el.remove();
      }, timeout);
    }
    return el;
  }

  let confirmResolve = null;
  let confirmOkAction = null;
  function confirmAsync(message, title) {
    const modal = document.getElementById("confirmModal");
    const msg = document.getElementById("confirmMessage");
    const ttl = document.getElementById("confirmTitle");
    if (!modal || !msg || !ttl) return Promise.resolve(false);
    msg.textContent = String(message || "");
    ttl.textContent = String(title || "Confirm");
    modal.classList.remove("hidden");
    modal.classList.add("flex");
    return new Promise((resolve) => {
      confirmResolve = resolve;
    });
  }
  function confirmAsyncWithOkAction(message, title, onOk) {
    confirmOkAction = typeof onOk === "function" ? onOk : null;
    return confirmAsync(message, title);
  }
  function resolveConfirm(result) {
    const action = confirmOkAction;
    const resolver = confirmResolve;
    confirmOkAction = null;
    confirmResolve = null;

    if (result && typeof action === "function") {
      try {
        action();
      } catch (e) {
        console.error("Confirm action error:", e);
      }
    }
    const modal = document.getElementById("confirmModal");
    if (modal) {
      modal.classList.add("hidden");
      modal.classList.remove("flex");
    }
    if (resolver) resolver(!!result);
  }

  // --- Settings Modal ---
  function openSettings() {
    const modal = document.getElementById("settingsModal");
    if (!modal) return;
    const savedTab = localStorage.getItem("diagram.settingsTab") || "ui";
    setSettingsTab(savedTab);
    modal.classList.remove("hidden");
    modal.classList.add("flex");
  }
  function closeSettings() {
    const modal = document.getElementById("settingsModal");
    if (!modal) return;
    modal.classList.add("hidden");
    modal.classList.remove("flex");
  }
  function setSettingsTab(tab) {
    const allowed = new Set(["ui", "guide", "apikey"]);
    const current = allowed.has(tab) ? tab : "ui";
    localStorage.setItem("diagram.settingsTab", current);

    document.querySelectorAll("[data-settings-panel]").forEach((panel) => {
      panel.classList.toggle(
        "hidden",
        panel.getAttribute("data-settings-panel") !== current
      );
    });
    document.querySelectorAll("[data-settings-tab]").forEach((btn) => {
      const active = btn.getAttribute("data-settings-tab") === current;
      btn.setAttribute("aria-pressed", active ? "true" : "false");
    });
  }

  function openPalette() {
    const modal = document.getElementById("paletteModal");
    if (!modal) return;
    modal.classList.remove("hidden");
    modal.classList.add("flex");
  }
  function closePalette() {
    const modal = document.getElementById("paletteModal");
    if (!modal) return;
    modal.classList.add("hidden");
    modal.classList.remove("flex");
  }

  function closeDownloadMenu() {
    const menu = document.getElementById("downloadMenu");
    if (!menu) return;
    menu.classList.add("hidden");
  }
  function toggleDownloadMenu(e) {
    if (e && typeof e.stopPropagation === "function") e.stopPropagation();
    const menu = document.getElementById("downloadMenu");
    if (!menu) return;
    menu.classList.toggle("hidden");
  }
  document.addEventListener("click", function (e) {
    const menu = document.getElementById("downloadMenu");
    const host = document.getElementById("downloadMenuHost");
    if (!menu || menu.classList.contains("hidden")) return;
    if (host && host.contains(e.target)) return;
    closeDownloadMenu();
  });
  window.addEventListener("keydown", function (e) {
    if (e && e.key === "Escape") closeDownloadMenu();
  });

  // --- Type Guide ---
  const TYPE_GUIDE = [
    {
      id: "auto",
      titleKey: "typeAuto",
      descKey: "typeAutoDesc",
      code: "flowchart TD\n  A[Prompt] --> B{Pick type}\n  B -->|Flow| C[Flowchart]\n  B -->|Time| D[Sequence]\n  B -->|Plan| E[Gantt]",
    },
    {
      id: "flowchart",
      titleKey: "typeFlowchart",
      descKey: "typeFlowchartDesc",
      code: "flowchart TD\n  A[Start] --> B{Decision}\n  B -->|Yes| C[OK]\n  B -->|No| D[Retry]\n  D --> B",
    },
    {
      id: "sequence",
      titleKey: "typeSequence",
      descKey: "typeSequenceDesc",
      code: "sequenceDiagram\n  participant U as User\n  participant S as System\n  U->>S: Request\n  S-->>U: Response",
    },
    {
      id: "gantt",
      titleKey: "typeGantt",
      descKey: "typeGanttDesc",
      code: "gantt\n  dateFormat  YYYY-MM-DD\n  title Project Plan\n  section Build\n  Design   :a1, 2025-01-01, 7d\n  Implement:after a1, 10d\n  Test     :after Implement, 5d",
    },
    {
      id: "class",
      titleKey: "typeClass",
      descKey: "typeClassDesc",
      code: "classDiagram\n  class User {\n    +String name\n    +login()\n  }\n  class Admin\n  Admin --|> User",
    },
    {
      id: "state",
      titleKey: "typeState",
      descKey: "typeStateDesc",
      code: "stateDiagram-v2\n  [*] --> Idle\n  Idle --> Working: start\n  Working --> Idle: stop",
    },
    {
      id: "er",
      titleKey: "typeEr",
      descKey: "typeErDesc",
      code: "erDiagram\n  CUSTOMER ||--o{ ORDER : places\n  ORDER ||--|{ LINE_ITEM : contains\n  CUSTOMER {\n    string name\n  }\n  ORDER {\n    string id\n  }",
    },
    {
      id: "journey",
      titleKey: "typeJourney",
      descKey: "typeJourneyDesc",
      code: "journey\n  title Shopping\n  section Browse\n    Find product: 5: User\n    Compare: 3: User\n  section Buy\n    Checkout: 2: User\n    Receive: 5: User",
    },
    {
      id: "pie",
      titleKey: "typePie",
      descKey: "typePieDesc",
      code: 'pie title Breakdown\n  "A" : 40\n  "B" : 35\n  "C" : 25',
    },
    {
      id: "git",
      titleKey: "typeGit",
      descKey: "typeGitDesc",
      code: "gitGraph\n  commit\n  branch feature\n  checkout feature\n  commit\n  checkout main\n  merge feature\n  commit",
    },
    {
      id: "c4",
      titleKey: "typeC4",
      descKey: "typeC4Desc",
      code: 'C4Context\n  title System Context\n  Person(user, "User")\n  System(app, "App")\n  Rel(user, app, "Uses")',
    },
    {
      id: "mindmap",
      titleKey: "typeMindmap",
      descKey: "typeMindmapDesc",
      code: "mindmap\n  root((Idea))\n    A\n      A1\n      A2\n    B\n      B1",
    },
  ];

  let typeHelpHasRendered = false;
  function openTypeHelp() {
    const modal = document.getElementById("typeHelpModal");
    if (!modal) return;
    modal.classList.remove("hidden");
    modal.classList.add("flex");
    if (!typeHelpHasRendered) {
      typeHelpHasRendered = true;
      renderTypeHelp();
    }
  }
  function closeTypeHelp() {
    const modal = document.getElementById("typeHelpModal");
    if (!modal) return;
    modal.classList.add("hidden");
    modal.classList.remove("flex");
  }

  async function renderTypeHelp() {
    const host = document.getElementById("typeHelpGrid");
    if (!host) return;

    host.innerHTML = TYPE_GUIDE.map((item) => {
      const title = escapeHtml(t(item.titleKey));
      const desc = escapeHtml(t(item.descKey));
      const code = escapeHtml(item.code);
      return (
        '<div class="type-help-card rounded-lg p-3 grid gap-2">' +
        '<div class="grid gap-0.5">' +
        '<div class="text-xs font-extrabold tracking-wide">' +
        title +
        "</div>" +
        '<div class="text-sm ui-muted leading-relaxed">' +
        desc +
        "</div>" +
        "</div>" +
        '<div class="type-help-preview rounded-lg p-3 overflow-hidden" id="typeHelpPreview-' +
        item.id +
        '"></div>' +
        '<details class="group">' +
        '<summary class="cursor-pointer select-none text-xs font-bold ui-muted hover:opacity-90 transition">' +
        escapeHtml(t("typeGuideCode")) +
        "</summary>" +
        '<pre class="type-help-code mt-2 rounded-lg p-3 text-xs overflow-auto whitespace-pre-wrap break-words"><code>' +
        code +
        "</code></pre>" +
        "</details>" +
        "</div>"
      );
    }).join("");

    const theme = getDiagramTheme();
    const config = Object.assign({}, getMermaidConfig(theme), {
      startOnLoad: false,
      securityLevel: "loose",
    });
    mermaid.initialize(config);

    for (let i = 0; i < TYPE_GUIDE.length; i++) {
      const item = TYPE_GUIDE[i];
      const target = document.getElementById("typeHelpPreview-" + item.id);
      if (!target) continue;
      target.innerHTML = '<div class="text-sm ui-muted">Loading...</div>';
      try {
        const id = "typeHelpSvg_" + item.id + "_" + Date.now() + "_" + i;
        const rendered = await mermaid.render(id, item.code);
        target.innerHTML = rendered.svg || "";
      } catch (e) {
        target.innerHTML =
          '<div class="text-sm ui-muted leading-relaxed">' +
          escapeHtml(t("typeGuideRenderError")) +
          "</div>";
      }
    }
  }

  // --- UI Theme ---
  function setUiTheme(theme) {
    const isLight = theme === "light";
    document.body.classList.toggle("ui-light", isLight);
    document.body.classList.toggle("ui-dark", !isLight);
    document.body.style.backgroundColor = isLight
      ? "var(--ui-bg)"
      : "var(--ui-bg)";
    syncUiThemeButtons();
  }
  function setUiThemeAndSync(theme) {
    const next = theme === "light" ? "light" : "dark";
    localStorage.setItem(UI_THEME_KEY, next);
    setUiTheme(next);
  }
  function syncUiThemeButtons() {
    const theme =
      localStorage.getItem(UI_THEME_KEY) ||
      (document.body.classList.contains("ui-light") ? "light" : "dark");
    document.querySelectorAll("[data-ui-theme]").forEach((btn) => {
      const active = btn.getAttribute("data-ui-theme") === theme;
      btn.setAttribute("aria-pressed", active ? "true" : "false");
    });
  }
  // --- Language (i18n) ---
  const I18N = {
    ja: {
      modalCancel: "キャンセル",
      modalOk: "OK",
      modalClose: "閉じる",
      settings: "設定",
      settingsTitle: "設定",
      typeGuideTitle: "タイプガイド",
      typeGuideIntro:
        "各タイプで作れる図のイメージ例です。クリックでコードも確認できます。",
      typeGuideOpenTitle: "タイプガイドを開く",
      typeGuideCode: "コードを見る",
      typeGuideRenderError: "プレビューを表示できません",
      uiTheme: "UIテーマ",
      lang: "言語",
      palette: "ノード / エッジ 色",
      node: "ノード",
      edge: "エッジ",
      paletteHint: "この設定はフローチャートのみ反映されます",
      uiDark: "ダーク",
      uiLight: "ライト",
      sidePanelTitle: "設定",
      prompt: "プロンプト",
      type: "タイプ",
      model: "モデル",
      generate: "生成する",
      thinking: "Thinking...",
      promptNeeded: "プロンプトを入力してください",
      generated: "生成しました",
      updatingPreview: "プレビュー更新中...",
      editNodeLabelTitle: "ノード名を編集",
      editEdgeLabelTitle: "エッジ名を編集",
      addEdgeTitle: "エッジを追加",
      nodeLabelPlaceholder: "ノード名",
      edgeLabelPlaceholder: "エッジ名（任意）",
      emptyMakesNoLabel: "空欄にするとラベルなしになります。",
      submitHint: "Ctrl/Cmd+Enterで確定。",
      sideTabCreate: "作成",
      sideTabEditor: "編集",
      sideTabHistory: "履歴",
      advanced: "詳細",
      codeEditor: "コード",
      preview: "プレビュー更新",
      geminiImageBtn: "Geminiで画像生成",
      geminiImageCopied: "画像生成用プロンプトをコピーしました",
      geminiImageEmpty: "Mermaidコードが空です",
      geminiOpenConfirm:
        "クリップボードにコピーしました。Geminiのページを開きますか？",
      imagePromptTitle: "画像生成プロンプト",
      imagePromptLangLabel: "言語",
      imagePromptStyleLabel: "スタイル",
      imagePromptCustomLabel: "スタイル追加（任意）",
      imagePromptNegativesLabel: "ネガティブ追加（任意）",
      imagePromptHint:
        "Mermaidのノード/分岐/サブグラフ名などのテキストも表示します（スライド風に整理）。",
      imagePromptOk: "生成してコピー",
      imagePromptCancel: "キャンセル",
      history: "履歴",
      historyEmpty: "履歴はまだありません",
      historyUpdating: "更新中...",
      historyLoading: "読み込み中...",
      historyDeleting: "削除中...",
      historyClearing: "全削除中...",
      historyRefreshTitle: "履歴を更新",
      historyClearTitle: "履歴を全削除",
      historyClearConfirm: "履歴をすべて削除します。よろしいですか？",
      historyRestoreTitle: "この履歴を復元",
      historyDeleteTitle: "削除",
      settingsTabUi: "UI",
      settingsTabGuide: "ガイド",
      settingsTabDraw: "描画",
      settingsTabHistory: "履歴",
      fontSizeLabel: "文字サイズ",
      fontSizeSmall: "小",
      fontSizeNormal: "普通",
      fontSizeLarge: "大",
      guideLabel: "操作ガイド",
      guideStepTitle: "基本の流れ",
      guideStep1: "テンプレートから選ぶ、または自由にプロンプトを入力します",
      guideStep2: "「生成する」ボタンまたは Ctrl + Enter で図を生成します",
      guideStep3: "微調整は Editor タブで直接コードを編集 → プレビュー更新をクリック",
      guideStep4: "フローチャート選択時のみ、エッジ追加や描画設定メニューが表示されます",
      guideStep5: "最新10件の履歴を保存。「さらに読み込む」で過去分も確認できます",
      guideShortcutTitle: "ショートカット",
      guideShortcut1: "図を生成する",
      guideShortcut2: "メニュー・モーダルを閉じる",
      guideExportTitle: "ダウンロード / 共有",
      guideExportText: "右上のダウンロードボタンから PNG / SVG / MD(Mermaid) 形式で保存可能です。",
      guideTipsTitle: "便利な機能・チップス",
      guideTips1: "• フローチャートの各パーツをクリックすると、ラベルを直接書き換えられます。",
      guideTips2: "• 図の上でドラッグすると移動、マウスホイールでズーム（拡大・縮小）が自在に行えます。",
      guideTips3: "• 「描画設定」から、ノードや線の色を自由に変更して見やすく調整可能です。",
      historySettingsLabel: "履歴",
      historyRefreshText: "更新",
      historyClearText: "全削除",
      historyLoadMoreText: "さらに読み込む",
      historyHint: "操作中はスピナーとオーバーレイで表示します。",
      typeAuto: "Auto（おまかせ）",
      typeAutoDesc: "内容に合わせて最適な図タイプを自動で選びます。",
      typeFlowchart: "Flowchart",
      typeFlowchartDesc: "処理フローや分岐を表現します。",
      typeSequence: "Sequence",
      typeSequenceDesc:
        "登場人物(オブジェクト)間のやり取りを時系列で表現します。",
      typeGantt: "Gantt",
      typeGanttDesc: "プロジェクト計画・スケジュールを表現します。",
      typeClass: "Class",
      typeClassDesc: "クラス構造や関連(継承/集約など)を表現します。",
      typeState: "State",
      typeStateDesc: "状態遷移を表現します。",
      typeEr: "ER",
      typeErDesc: "データのエンティティと関係を表現します。",
      typeJourney: "Journey",
      typeJourneyDesc: "ユーザージャーニーを段階と満足度で表現します。",
      typePie: "Pie",
      typePieDesc: "割合を表現します。",
      typeGit: "Git",
      typeGitDesc: "ブランチ/マージなどの履歴を表現します。",
      typeC4: "C4",
      typeC4Desc: "システムの関係（コンテキスト）を表現します。",
      typeMindmap: "Mindmap",
      typeMindmapDesc: "アイデアを階層構造で整理します。",
      copyErrorLog: "エラーログをコピー",
      errorLogCopied: "エラーログをクリップボードにコピーしました",
    },
    en: {
      modalCancel: "Cancel",
      modalOk: "OK",
      modalClose: "Close",
      settings: "Settings",
      settingsTitle: "SETTINGS",
      typeGuideTitle: "Type Guide",
      typeGuideIntro:
        "Example diagrams for each type. Click to view the sample code.",
      typeGuideOpenTitle: "Open type guide",
      typeGuideCode: "View code",
      typeGuideRenderError: "Preview unavailable",
      uiTheme: "UI THEME",
      lang: "LANGUAGE",
      palette: "NODE / EDGE COLOR",
      node: "Node",
      edge: "Edge",
      paletteHint: "Applies to Mermaid (mainly Flowchart)",
      uiDark: "DARK",
      uiLight: "LIGHT",
      sidePanelTitle: "Settings",
      prompt: "Prompt",
      type: "Type",
      model: "Model",
      generate: "Generate",
      thinking: "Thinking...",
      promptNeeded: "Enter a prompt",
      generated: "Generated",
      updatingPreview: "Updating preview...",
      editNodeLabelTitle: "Edit node label",
      editEdgeLabelTitle: "Edit edge label",
      addEdgeTitle: "Add edge",
      nodeLabelPlaceholder: "Node label",
      edgeLabelPlaceholder: "Edge label (optional)",
      emptyMakesNoLabel: "Leave empty to remove the label.",
      submitHint: "Press Ctrl/Cmd+Enter to submit.",
      sideTabCreate: "Create",
      sideTabEditor: "Editor",
      sideTabHistory: "History",
      advanced: "Advanced",
      codeEditor: "Code",
      preview: "Refresh Preview",
      geminiImageBtn: "Generate image in Gemini",
      geminiImageCopied: "Image prompt copied to clipboard",
      geminiImageEmpty: "Mermaid code is empty",
      geminiOpenConfirm: "Copied to clipboard. Open Gemini now?",
      imagePromptTitle: "Image prompt",
      imagePromptLangLabel: "Language",
      imagePromptStyleLabel: "Style",
      imagePromptCustomLabel: "Custom style (optional)",
      imagePromptNegativesLabel: "Extra negatives (optional)",
      imagePromptHint: "Renders text labels from Mermaid (slide-like layout).",
      imagePromptOk: "Generate & Copy",
      imagePromptCancel: "Cancel",
      history: "History",
      historyEmpty: "No history yet",
      historyUpdating: "Updating...",
      historyLoading: "Loading...",
      historyDeleting: "Deleting...",
      historyClearing: "Clearing...",
      historyRefreshTitle: "Refresh history",
      historyClearTitle: "Clear history",
      historyClearConfirm: "Delete all history entries?",
      historyRestoreTitle: "Restore this entry",
      historyDeleteTitle: "Delete",
      settingsTabUi: "UI",
      settingsTabGuide: "Guide",
      settingsTabDraw: "Draw",
      settingsTabHistory: "History",
      fontSizeLabel: "TEXT SIZE",
      fontSizeSmall: "Small",
      fontSizeNormal: "Normal",
      fontSizeLarge: "Large",
      guideLabel: "GUIDE",
      guideStepTitle: "Basic Flow",
      guideStep1: "Pick a template or enter your own prompt to start",
      guideStep2: "Click 'Generate' or press Ctrl + Enter to create the diagram",
      guideStep3: "Fine-tune in the 'Editor' tab by editing code directly → 'Refresh Preview'",
      guideStep4: "Extra tools like 'Add Edge' or 'Draw' are available for Flowcharts",
      guideStep5: "Auto-saves the latest 10 items. Click 'Load more' for older history",
      guideShortcutTitle: "Shortcuts",
      guideShortcut1: "Generate diagram",
      guideShortcut2: "Close current menu/modal",
      guideExportTitle: "Download & Export",
      guideExportText: "Use the download icon (top-right) to save as PNG, SVG, or MD (Mermaid).",
      guideTipsTitle: "Advanced Features & Tips",
      guideTips1: "• Click any node in a Flowchart to edit its label text interactively.",
      guideTips2: "• Click and drag to pan the diagram; use the scroll wheel to zoom in/out.",
      guideTips3: "• Customize appearance in 'Draw' to change node and edge colors.",
      historySettingsLabel: "History",
      historyRefreshText: "Refresh",
      historyClearText: "Clear",
      historyLoadMoreText: "Load more",
      historyHint: "Shows spinner/overlay while processing.",
      typeAuto: "Auto",
      typeAutoDesc:
        "Automatically picks a suitable diagram type from your prompt.",
      typeFlowchart: "Flowchart",
      typeFlowchartDesc: "Shows processes and branching logic.",
      typeSequence: "Sequence",
      typeSequenceDesc: "Shows interactions over time between participants.",
      typeGantt: "Gantt",
      typeGanttDesc: "Shows project schedules and tasks.",
      typeClass: "Class",
      typeClassDesc: "Shows classes and relationships.",
      typeState: "State",
      typeStateDesc: "Shows state transitions.",
      typeEr: "ER",
      typeErDesc: "Shows entities and database relationships.",
      typeJourney: "Journey",
      typeJourneyDesc: "Shows user journey steps and sentiment.",
      typePie: "Pie",
      typePieDesc: "Shows proportions.",
      typeGit: "Git",
      typeGitDesc: "Shows branching and merging history.",
      typeC4: "C4",
      typeC4Desc: "Shows system context relationships.",
      typeMindmap: "Mindmap",
      typeMindmapDesc: "Organizes ideas hierarchically.",
      copyErrorLog: "Copy Error Log",
      errorLogCopied: "Error log copied to clipboard",
    },
  };
  function getCurrentLang() {
    const raw = localStorage.getItem(UI_LANG_KEY) || "ja";
    return raw === "en" ? "en" : "ja";
  }
  function t(key) {
    const lang = getCurrentLang();
    const dict = I18N[lang];
    if (dict && dict[key] != null) return dict[key];
    return key;
  }
  function setLanguage(lang) {
    const next = lang === "en" ? "en" : "ja";
    const t = I18N[next];
    const settingsBtn = document.getElementById("settingsBtn");
    if (settingsBtn) settingsBtn.title = t.settings;
    const settingsTitle = document.getElementById("settingsTitle");
    if (settingsTitle) settingsTitle.textContent = t.settingsTitle;

    const confirmCancelBtn = document.getElementById("confirmCancelBtn");
    if (confirmCancelBtn)
      confirmCancelBtn.textContent = t.modalCancel || "Cancel";
    const confirmOkBtn = document.getElementById("confirmOkBtn");
    if (confirmOkBtn) confirmOkBtn.textContent = t.modalOk || "OK";
    const textEditCancelBtn = document.getElementById("textEditCancelBtn");
    if (textEditCancelBtn)
      textEditCancelBtn.textContent = t.modalCancel || "Cancel";
    const textEditOkBtn = document.getElementById("textEditOkBtn");
    if (textEditOkBtn) textEditOkBtn.textContent = t.modalOk || "OK";
    const textEditCloseBtn = document.getElementById("textEditCloseBtn");
    if (textEditCloseBtn) textEditCloseBtn.title = t.modalClose || "Close";
    const typeHelpTitle = document.getElementById("typeHelpTitle");
    if (typeHelpTitle) typeHelpTitle.textContent = t.typeGuideTitle;
    const typeHelpIntro = document.getElementById("typeHelpIntro");
    if (typeHelpIntro) typeHelpIntro.textContent = t.typeGuideIntro;
    const typeHelpOpenBtn = document.getElementById("typeHelpOpenBtn");
    if (typeHelpOpenBtn) typeHelpOpenBtn.title = t.typeGuideOpenTitle;
    const uiThemeLabel = document.getElementById("uiThemeLabel");
    if (uiThemeLabel) uiThemeLabel.textContent = t.uiTheme;
    const langLabel = document.getElementById("langLabel");
    if (langLabel) langLabel.textContent = t.lang;
    const fontSizeLabel = document.getElementById("fontSizeLabel");
    if (fontSizeLabel)
      fontSizeLabel.textContent = t.fontSizeLabel || "TEXT SIZE";
    const fontSizeSmall = document.getElementById("fontSizeSmall");
    if (fontSizeSmall) fontSizeSmall.textContent = t.fontSizeSmall || "Small";
    const fontSizeNormal = document.getElementById("fontSizeNormal");
    if (fontSizeNormal)
      fontSizeNormal.textContent = t.fontSizeNormal || "Normal";
    const fontSizeLarge = document.getElementById("fontSizeLarge");
    if (fontSizeLarge) fontSizeLarge.textContent = t.fontSizeLarge || "Large";
    const paletteLabel = document.getElementById("paletteLabel");
    if (paletteLabel) paletteLabel.textContent = t.palette;
    const paletteModalTitle = document.getElementById("paletteModalTitle");
    if (paletteModalTitle) paletteModalTitle.textContent = t.palette;
    const paletteModalHint = document.getElementById("paletteModalHint");
    if (paletteModalHint) paletteModalHint.textContent = t.paletteHint;
    const nodeLabel = document.getElementById("nodeColorLabel");
    if (nodeLabel) nodeLabel.textContent = t.node;
    const edgeLabel = document.getElementById("edgeColorLabel");
    if (edgeLabel) edgeLabel.textContent = t.edge;
    const hint = document.getElementById("paletteHint");
    if (hint) hint.textContent = t.paletteHint;

    const uiThemeDarkBtn = document.getElementById("uiThemeDarkBtn");
    if (uiThemeDarkBtn) uiThemeDarkBtn.textContent = t.uiDark;
    const uiThemeLightBtn = document.getElementById("uiThemeLightBtn");
    if (uiThemeLightBtn) uiThemeLightBtn.textContent = t.uiLight;

    if (typeof setSideTab === "function")
      setSideTab(localStorage.getItem(SIDE_TAB_KEY) || "create", {
        store: false,
      });
    const promptLabel = document.getElementById("promptLabel");
    if (promptLabel) promptLabel.textContent = t.prompt;
    const typeLabel = document.getElementById("typeLabel");
    if (typeLabel) typeLabel.textContent = t.type;
    const generateText = document.getElementById("generateText");
    if (generateText) generateText.textContent = t.generate;
    const codeEditorLabel = document.getElementById("codeEditorLabel");
    if (codeEditorLabel) codeEditorLabel.textContent = t.codeEditor;
    const previewText = document.getElementById("previewUpdateText");
    if (previewText) previewText.textContent = t.preview;
    const geminiImageBtnText = document.getElementById("geminiImageBtnText");
    if (geminiImageBtnText) geminiImageBtnText.textContent = t.geminiImageBtn;
    const geminiImageBtn = document.getElementById("geminiImageBtn");
    if (geminiImageBtn) geminiImageBtn.title = t.geminiImageBtn;
    const geminiImageHeaderBtn = document.getElementById(
      "geminiImageHeaderBtn"
    );
    if (geminiImageHeaderBtn) geminiImageHeaderBtn.title = t.geminiImageBtn;

    const imagePromptTitle = document.getElementById("imagePromptTitle");
    if (imagePromptTitle)
      imagePromptTitle.textContent = t.imagePromptTitle || "Image prompt";
    const imagePromptLangLabel = document.getElementById(
      "imagePromptLangLabel"
    );
    if (imagePromptLangLabel)
      imagePromptLangLabel.textContent = t.imagePromptLangLabel || "Language";
    const imagePromptStyleLabel = document.getElementById(
      "imagePromptStyleLabel"
    );
    if (imagePromptStyleLabel)
      imagePromptStyleLabel.textContent = t.imagePromptStyleLabel || "Style";
    const imagePromptCustomLabel = document.getElementById(
      "imagePromptCustomLabel"
    );
    if (imagePromptCustomLabel)
      imagePromptCustomLabel.textContent =
        t.imagePromptCustomLabel || "Custom style (optional)";
    const imagePromptNegativesLabel = document.getElementById(
      "imagePromptNegativesLabel"
    );
    if (imagePromptNegativesLabel)
      imagePromptNegativesLabel.textContent =
        t.imagePromptNegativesLabel || "Extra negatives (optional)";
    const imagePromptHint = document.getElementById("imagePromptHint");
    if (imagePromptHint) imagePromptHint.textContent = t.imagePromptHint || "";
    const imagePromptCancelBtn = document.getElementById(
      "imagePromptCancelBtn"
    );
    if (imagePromptCancelBtn)
      imagePromptCancelBtn.textContent =
        t.imagePromptCancel || t.modalCancel || "Cancel";
    const imagePromptOkBtn = document.getElementById("imagePromptOkBtn");
    if (imagePromptOkBtn)
      imagePromptOkBtn.textContent = t.imagePromptOk || t.modalOk || "OK";
    const historyLabel = document.getElementById("historyLabelText");
    if (historyLabel) historyLabel.textContent = t.history;

    const clearHistoryBtn = document.getElementById("clearHistoryBtn");
    if (clearHistoryBtn) clearHistoryBtn.title = t.historyClearTitle;
    const historyStatusText = document.getElementById("historyStatusText");
    const historyStatusEl = document.getElementById("historyStatus");
    if (
      historyStatusText &&
      historyStatusEl &&
      !historyStatusEl.classList.contains("hidden")
    )
      historyStatusText.textContent = t.historyUpdating;
    const historyOverlayText = document.getElementById("historyOverlayText");
    const historyOverlayEl = document.getElementById("historyOverlay");
    if (
      historyOverlayText &&
      historyOverlayEl &&
      !historyOverlayEl.classList.contains("hidden")
    )
      historyOverlayText.textContent = t.historyUpdating;

    const tabUi = document.getElementById("settingsTabUi");
    if (tabUi) tabUi.textContent = t.settingsTabUi;
    const tabGuide = document.getElementById("settingsTabGuide");
    if (tabGuide) tabGuide.textContent = t.settingsTabGuide || "GUIDE";
    const tabDraw = document.getElementById("settingsTabDraw");
    if (tabDraw) tabDraw.textContent = t.settingsTabDraw;
    const tabHistory = document.getElementById("settingsTabHistory");
    if (tabHistory) tabHistory.textContent = t.settingsTabHistory;
    const guideLabel = document.getElementById("guideLabel");
    if (guideLabel) guideLabel.textContent = t.guideLabel || "GUIDE";
    const guideStepTitle = document.getElementById("guideStepTitle");
    if (guideStepTitle)
      guideStepTitle.textContent = t.guideStepTitle || "Basic Flow";
    const guideStep1 = document.getElementById("guideStep1");
    if (guideStep1) guideStep1.textContent = t.guideStep1 || "";
    const guideStep2 = document.getElementById("guideStep2");
    if (guideStep2) guideStep2.textContent = t.guideStep2 || "";
    const guideStep3 = document.getElementById("guideStep3");
    if (guideStep3) guideStep3.textContent = t.guideStep3 || "";
    const guideStep4 = document.getElementById("guideStep4");
    if (guideStep4) guideStep4.textContent = t.guideStep4 || "";
    const guideStep5 = document.getElementById("guideStep5");
    if (guideStep5) guideStep5.textContent = t.guideStep5 || "";
    const guideShortcutTitle = document.getElementById("guideShortcutTitle");
    if (guideShortcutTitle)
      guideShortcutTitle.textContent = t.guideShortcutTitle || "Shortcuts";
    const guideShortcut1 = document.getElementById("guideShortcut1");
    if (guideShortcut1) guideShortcut1.textContent = t.guideShortcut1 || "";
    const guideExportTitle = document.getElementById("guideExportTitle");
    if (guideExportTitle)
      guideExportTitle.textContent = t.guideExportTitle || "Download";
    const guideExportText = document.getElementById("guideExportText");
    if (guideExportText) guideExportText.textContent = t.guideExportText || "";

    const guideTipsTitle = document.getElementById("guideTipsTitle");
    if (guideTipsTitle)
      guideTipsTitle.textContent = t.guideTipsTitle || "Tips";
    const guideTips1 = document.getElementById("guideTips1");
    if (guideTips1) guideTips1.textContent = t.guideTips1 || "";
    const guideTips2 = document.getElementById("guideTips2");
    if (guideTips2) guideTips2.textContent = t.guideTips2 || "";
    const guideTips3 = document.getElementById("guideTips3");
    if (guideTips3) {
      guideTips3.textContent = t.guideTips3 || "";
      guideTips3.classList.remove("hidden");
    } else if (t.guideTips3) {
      // If guideTips3 element doesn't exist but translation does, we might want to append it
      const parent = document.getElementById("guideTips2") ? document.getElementById("guideTips2").parentNode : null;
      if (parent) {
        const p = document.createElement("p");
        p.id = "guideTips3";
        p.className = "font-medium";
        p.textContent = t.guideTips3;
        parent.appendChild(p);
      }
    }
    const historySettingsLabel = document.getElementById(
      "historySettingsLabel"
    );
    if (historySettingsLabel)
      historySettingsLabel.textContent = t.historySettingsLabel;
    const historyClearText = document.getElementById("historyClearText");
    if (historyClearText) historyClearText.textContent = t.historyClearText;
    const historyLoadMoreText = document.getElementById("historyLoadMoreText");
    if (historyLoadMoreText)
      historyLoadMoreText.textContent = t.historyLoadMoreText || "Load more";
    const historyHint = document.getElementById("historyHint");
    if (historyHint) historyHint.textContent = t.historyHint;

    document.querySelectorAll("[data-side-tab]").forEach((btn) => {
      const key = btn.getAttribute("data-side-tab");
      if (key === "create") btn.textContent = t.sideTabCreate || "Create";
      if (key === "editor") btn.textContent = t.sideTabEditor || "Editor";
      if (key === "history") btn.textContent = t.sideTabHistory || "History";
    });
    // If the type guide has been rendered once, refresh labels in-place.
    if (typeHelpHasRendered) renderTypeHelp();
    syncLanguageButtons();
  }
  function setLanguageAndSync(lang) {
    const next = lang === "en" ? "en" : "ja";
    localStorage.setItem(UI_LANG_KEY, next);
    setLanguage(next);
  }
  function syncLanguageButtons() {
    const lang = localStorage.getItem(UI_LANG_KEY) || "ja";
    document.querySelectorAll("[data-lang]").forEach((btn) => {
      const active = btn.getAttribute("data-lang") === lang;
      btn.setAttribute("aria-pressed", active ? "true" : "false");
    });
  }

  // --- Palette ---
  function getPalette() {
    const nodeInput = document.getElementById("nodeColorInput");
    const edgeInput = document.getElementById("edgeColorInput");
    const node = (
      (nodeInput ? nodeInput.value : null) ||
      localStorage.getItem(PALETTE_NODE_KEY) ||
      "#60a5fa"
    ).toLowerCase();
    const edge = (
      (edgeInput ? edgeInput.value : null) ||
      localStorage.getItem(PALETTE_EDGE_KEY) ||
      "#94a3b8"
    ).toLowerCase();
    return { node, edge };
  }
  function onPaletteChange() {
    const { node, edge } = getPalette();
    localStorage.setItem(PALETTE_NODE_KEY, node);
    localStorage.setItem(PALETTE_EDGE_KEY, edge);
    renderPalettePresets();
    if (document.getElementById("mermaidCode").value) renderDiagram();
  }
  function renderPalettePresets() {
    const host = document.getElementById("palettePresets");
    if (!host) return;
    const presets = [
      { name: "Blue", node: "#60a5fa", edge: "#94a3b8" },
      { name: "Emerald", node: "#34d399", edge: "#10b981" },
      { name: "Violet", node: "#a78bfa", edge: "#6366f1" },
    ];
    const current = getPalette();
    host.innerHTML = presets
      .map((p) => {
        const active =
          p.node.toLowerCase() === current.node &&
          p.edge.toLowerCase() === current.edge;
        const ring = active
          ? "2px solid var(--canvas-control-focus, rgba(96,165,250,0.9))"
          : "1px solid var(--ui-border)";
        return (
          '<button type="button" class="ui-surface rounded-lg px-2.5 py-2 text-xs font-bold transition" style="border:' +
          ring +
          '" onclick="applyPalettePreset(&quot;' +
          p.node +
          "&quot;,&quot;" +
          p.edge +
          '&quot;)" title="' +
          p.name +
          '"><span class="inline-flex items-center gap-2"><span class="inline-block w-3 h-3 rounded" style="background:' +
          p.node +
          '"></span><span class="inline-block w-3 h-3 rounded" style="background:' +
          p.edge +
          '"></span>' +
          p.name +
          "</span></button>"
        );
      })
      .join("");
  }
  function applyPalettePreset(node, edge) {
    const nodeInput = document.getElementById("nodeColorInput");
    const edgeInput = document.getElementById("edgeColorInput");
    if (nodeInput) nodeInput.value = node;
    if (edgeInput) edgeInput.value = edge;
    onPaletteChange();
  }

  function changeTheme(options) {
    const opts = options && typeof options === "object" ? options : {};
    const theme = getDiagramTheme();
    updateThemeChips(theme);
    if (!opts.skipRender && document.getElementById("mermaidCode").value)
      renderDiagram();
  }

  function setupPanZoom() {
    const wrapper = document.getElementById("diagram-wrapper");
    const output = document.getElementById("diagram-output");

    // 重要: 計算を単純化するために変形の原点を左上に固定します
    if (output) {
      output.style.transformOrigin = "0 0";
    }

    function hasClosest(el, sel) {
      try {
        return !!(el && el.closest && el.closest(sel));
      } catch (_) {
        return false;
      }
    }

    // マウスドラッグ（パン操作）
    wrapper.addEventListener("mousedown", (e) => {
      if (
        hasClosest(e.target, "button") ||
        hasClosest(e.target, "select") ||
        hasClosest(e.target, "g.node") ||
        hasClosest(e.target, "g.edgePath") ||
        hasClosest(e.target, "g.edgeLabel")
      )
        return;
      isPanning = true;
      startX = e.clientX - pointX;
      startY = e.clientY - pointY;
      wrapper.style.cursor = "grabbing";
    });

    window.addEventListener("mousemove", (e) => {
      if (!isPanning) return;
      e.preventDefault();
      pointX = e.clientX - startX;
      pointY = e.clientY - startY;
      updateTransform();
    });

    window.addEventListener("mouseup", () => {
      isPanning = false;
      wrapper.style.cursor = "grab";
    });

    function clampScale(next) {
      const v = Number(next);
      if (!Number.isFinite(v)) return scale;
      return Math.max(MIN_SCALE, Math.min(MAX_SCALE, v));
    }

    // タッチ操作用の中点計算
    function getTouchMidpoint(touches) {
      const rect = wrapper.getBoundingClientRect();
      const clientX = (touches[0].clientX + touches[1].clientX) / 2;
      const clientY = (touches[0].clientY + touches[1].clientY) / 2;
      return {
        x: clientX - rect.left,
        y: clientY - rect.top,
      };
    }

    // ホイールズーム（マウス位置中心）
    wrapper.addEventListener(
      "wheel",
      (e) => {
        e.preventDefault();

        // 1. コンテナの位置を取得してマウス座標を相対化する
        const rect = wrapper.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        // 2. 現在のスケールでの「マウス下の論理座標」を計算
        const worldX = (mouseX - pointX) / scale;
        const worldY = (mouseY - pointY) / scale;

        // 3. スケール更新
        const delta = -e.deltaY;
        const factor = delta > 0 ? 1.1 : 1 / 1.1;
        const nextScale = clampScale(scale * factor);
        if (nextScale === scale) return;
        scale = nextScale;

        // 4. 新しいスケールでも「マウス下の論理座標」が同じ位置に来るように pointX/Y を逆算
        // mouseX = pointX_new + worldX * scale_new
        // ∴ pointX_new = mouseX - worldX * scale_new
        pointX = mouseX - worldX * scale;
        pointY = mouseY - worldY * scale;

        updateTransform();
      },
      { passive: false }
    );

    // タッチ操作（ピンチイン・アウト）
    wrapper.addEventListener(
      "touchstart",
      (e) => {
        if (
          hasClosest(e.target, "button") ||
          hasClosest(e.target, "select") ||
          hasClosest(e.target, "g.node") ||
          hasClosest(e.target, "g.edgePath") ||
          hasClosest(e.target, "g.edgeLabel")
        )
          return;

        if (e.touches.length === 1) {
          isPanning = true;
          startX = e.touches[0].clientX - pointX;
          startY = e.touches[0].clientY - pointY;
        } else if (e.touches.length === 2) {
          isPanning = false;
          initialPinchDistance = getDistance(e.touches);
          lastScale = scale;

          // ピンチ開始時の中心点と論理座標を保存
          const mid = getTouchMidpoint(e.touches);
          // 修正: ここでも相対座標を使って計算
          pinchWorldX = (mid.x - pointX) / scale;
          pinchWorldY = (mid.y - pointY) / scale;
        }
      },
      { passive: false }
    );

    wrapper.addEventListener(
      "touchmove",
      (e) => {
        e.preventDefault();
        if (isPanning && e.touches.length === 1) {
          pointX = e.touches[0].clientX - startX;
          pointY = e.touches[0].clientY - startY;
          updateTransform();
          return;
        }
        if (e.touches.length === 2 && initialPinchDistance) {
          const dist = getDistance(e.touches);
          const nextScale = clampScale(
            lastScale * (dist / initialPinchDistance)
          );

          const mid = getTouchMidpoint(e.touches);
          scale = nextScale;

          // ホイールと同様のロジックで位置補正
          pointX = mid.x - pinchWorldX * scale;
          pointY = mid.y - pinchWorldY * scale;

          updateTransform();
        }
      },
      { passive: false }
    );

    wrapper.addEventListener(
      "touchend",
      (e) => {
        if (e.touches.length === 1) {
          // ピンチ終了後に指が1本残っていたらスムーズにパン操作へ移行
          isPanning = true;
          startX = e.touches[0].clientX - pointX;
          startY = e.touches[0].clientY - pointY;
        } else {
          isPanning = false;
        }
        if (e.touches.length < 2) initialPinchDistance = null;
      },
      { passive: false }
    );
  }

  function getDistance(touches) {
    const dx = touches[0].clientX - touches[1].clientX;
    const dy = touches[0].clientY - touches[1].clientY;
    return Math.sqrt(dx * dx + dy * dy);
  }
  function updateTransform() {
    document.getElementById("diagram-output").style.transform =
      "translate(" + pointX + "px, " + pointY + "px) scale(" + scale + ")";
  }
  function zoomIn() {
    scale *= 1.2;
    updateTransform();
  }
  function zoomOut() {
    scale /= 1.2;
    updateTransform();
  }
  function resetZoom() {
    scale = 1;
    pointX = 0;
    pointY = 0;
    updateTransform();
  }

  // --- Generation Logic ---
  function startGeneration() {
    const input = document.getElementById("userInput").value;
    const model = "flash-lite"; // Fixed to Gemini Flash Lite
    const diagramType = document.getElementById("diagramTypeSelect").value;

    // ファイルがある場合はプロンプト空でもOKとする（画像の説明などを求める場合があるため）
    if (!input && !currentFile) {
      showToast("info", "プロンプトを入力するか、ファイルを添付してください");
      return;
    }

    if (window.innerWidth < 768) {
      togglePanel(false);
    }

    setAppState(APP_STATE.generating);
    showLoading(true, "THINKING...");
    currentRetry = 0;
    proFallbackUsed = 0;
    repairHistory = [];
    pendingHistorySave = true;

    // 引数に currentFile を追加
    google.script.run
      .withSuccessHandler(onSuccess)
      .withFailureHandler(onFailure)
      .callGeminiAPI(
        input,
        model,
        diagramType,
        currentFile,
        null, // currentCode
        null, // errorMessage
        null, // retryHistory
        getCurrentLang(),
        getApiKey(),
        null // temperatureOverride
      );
  }

  function onSuccess(code) {
    const safeCode = repairCommonSyntaxErrors(String(code || ""));
    document.getElementById("mermaidCode").value = safeCode;
    renderDiagram(true);
  }

  function onFailure(error) {
    showLoading(false);
    togglePanel(true);
    if (pendingHistorySave) {
      const msg = error && error.message ? error.message : String(error);
      saveHistory({ error: msg, reason: "api_error" });
      pendingHistorySave = false;
    }
    setAppState(APP_STATE.error, {
      message: error && error.message ? error.message : String(error),
    });
  }

  function buildRecoveryErrorContext(error, codeText) {
    const msg = error && error.message ? String(error.message) : String(error || "");
    const src = String(codeText || "");
    const out = [];
    if (msg) out.push(msg);
    const hash = error && error.hash ? error.hash : null;
    const loc = hash && hash.loc ? hash.loc : null;
    if (loc && Number.isFinite(loc.first_line)) {
      const lineNo = Math.max(1, Number(loc.first_line));
      const lines = src.split(/\r?\n/);
      const lineText = lineNo <= lines.length ? String(lines[lineNo - 1] || "").trim() : "";
      out.push("line " + lineNo + (lineText ? ": " + lineText : ""));
    }
    return out.join(" | ").slice(0, 1200);
  }

  function scheduleRenderDiagram(enableAutoRepair) {
    if (isRenderRunning) {
      queuedRenderAutoRepair = !!enableAutoRepair || !!queuedRenderAutoRepair;
      return;
    }
    showLoading(
      true,
      typeof t === "function" ? t("updatingPreview") : "Updating preview..."
    );
    window.setTimeout(() => {
      Promise.resolve(renderDiagram(!!enableAutoRepair)).catch((e) => {
        console.error("Render failed:", e);
        showLoading(false);
        showToast("error", e && e.message ? e.message : String(e));
      });
    }, 0);
  }

  async function renderDiagram(enableAutoRepair = false) {
    if (isRenderRunning) {
      queuedRenderAutoRepair = !!enableAutoRepair || !!queuedRenderAutoRepair;
      return false;
    }
    isRenderRunning = true;
    try {
      sessionStorage.setItem(RENDER_INFLIGHT_KEY, "1");
    } catch (_) { }

    const wasGenerating = appState === APP_STATE.generating;
    const code = document.getElementById("mermaidCode").value;
    const outputDiv = document.getElementById("diagram-output");
    const theme = getDiagramTheme();

    console.group("🎨 [De:gram] Render Diagram");
    console.log("Raw Code from Textarea:", code); // 描画直前のコード

    syncFlowOnlyControls(code);
    const repairedCode = repairCommonSyntaxErrors(code);
    const layoutedCode = applyResponsiveLayout(repairedCode);

    console.log("Layout Adjusted Code:", layoutedCode); // レイアウト調整後のコード

    const mermaidConfig = getMermaidConfig(theme);
    mermaid.initialize(mermaidConfig);
    try {
      await mermaid.parse(layoutedCode);
      outputDiv.innerHTML = "";
      const id = "graphDiv" + Date.now();
      const { svg } = await mermaid.render(id, layoutedCode);
      if (svg && /Syntax error in text/i.test(svg)) {
        throw new Error("Syntax error in diagram");
      }
      outputDiv.innerHTML = svg;
      setupInlineLabelEditing(outputDiv);
      outputDiv.classList.remove("opacity-0");
      clearCanvasError();
      showLoading(false);
      document.getElementById("retryCount").classList.add("hidden");
      if (pendingHistorySave) {
        pendingHistorySave = false;
        saveHistory({ reason: "auto" });
      }
      if (wasGenerating) setAppState(APP_STATE.success);
      else syncAppStateFromInputs();
      console.log("✅ Render Successful");
      console.groupEnd();
      return true;
    } catch (error) {
      console.error("❌ Render Failed:", error);
      console.log("Failed Code Snippet:", layoutedCode); // エラーを起こした確定的なコード

      // エラーオブジェクトの詳細を展開
      if (error.hash) console.error("Error Hash:", error.hash);
      console.groupEnd();
      console.error("Mermaid Error:", error);
      if (enableAutoRepair) {
        const input = document.getElementById("userInput").value;
        const selectedModel = "flash-lite";
        const diagramType = document.getElementById("diagramTypeSelect").value;

        // record failure (keep last few only)
        const lastModel = selectedModel;
        repairHistory.push({
          attempt: repairHistory.length + 1,
          model: lastModel,
          error: String(error && error.message ? error.message : error),
          code: String(code || ""),
        });
        if (repairHistory.length > 6) repairHistory = repairHistory.slice(-6);

        const canRetry = currentRetry < MAX_RETRIES;

        if (canRetry) {
          currentRetry++;

          let nextModel = selectedModel;
          const userKey = getApiKey();

          // 3rd retry: Upgrade to Flash ONLY if personal key exists
          if (currentRetry >= 3 && userKey) {
            nextModel = "flash";
          }

          // Temperature override
          // 1st retry: null (default 0.2)
          // 2nd retry: 0.5
          // 3rd retry: 0.7 (if no key upgrade)
          let nextTemp = null;
          if (currentRetry === 2) nextTemp = 0.5;
          if (currentRetry >= 3 && !userKey) nextTemp = 0.7;

          document.getElementById("retryCount").classList.remove("hidden");
          const modelNameDisplay = nextModel === "flash" ? "Flash" : "Flash-Lite";
          showLoading(
            true,
            "REPAIRING... (" + currentRetry + "/" + MAX_RETRIES + ") [" + modelNameDisplay + "]"
          );

          if (repairHistory.length > 0) {
            repairHistory[repairHistory.length - 1].__nextModel = nextModel;
          }

          google.script.run
            .withSuccessHandler(onSuccess)
            .withFailureHandler(onFailure)
            .callGeminiAPI(
              input,
              nextModel,
              diagramType,
              currentFile,
              null, // Force fresh generation (no currentCode)
              buildRecoveryErrorContext(error, layoutedCode), // Provide richer error context for recovery mode
              JSON.stringify(repairHistory),
              getCurrentLang(),
              userKey,
              nextTemp
            );
          return false;
        }
      }
      // fallthrough: auto-repair disabled OR exhausted
      showLoading(false);
      togglePanel(true);
      if (pendingHistorySave) {
        const msg = error && error.message ? error.message : String(error);
        saveHistory({ error: msg, reason: "render_error" });
        pendingHistorySave = false;
      }
      outputDiv.innerHTML = "";
      outputDiv.classList.add("opacity-0");
      const msg =
        error && error.message ? String(error.message) : String(error);
      if (wasGenerating) {
        setAppState(APP_STATE.error, { message: msg, sticky: true });
      } else {
        showCanvasError(msg);
        syncAppStateFromInputs();
      }
      return false;
    } finally {
      isRenderRunning = false;
      try {
        sessionStorage.removeItem(RENDER_INFLIGHT_KEY);
      } catch (_) { }

      if (queuedRenderAutoRepair !== null) {
        const queued = queuedRenderAutoRepair;
        queuedRenderAutoRepair = null;
        window.setTimeout(() => {
          Promise.resolve(renderDiagram(queued)).catch((e) => {
            console.error("Render failed (queued):", e);
            showLoading(false);
            showToast("error", e && e.message ? e.message : String(e));
          });
        }, 0);
      }
    }
  }

  function setupInlineLabelEditing(rootEl) {
    const root =
      rootEl && rootEl.addEventListener
        ? rootEl
        : document.getElementById("diagram-output");
    if (!root) return;
    if (root.__inlineEditBound) return;
    root.__inlineEditBound = true;

    root.addEventListener("click", function (e) {
      const codeEl = document.getElementById("mermaidCode");
      const code = codeEl ? codeEl.value || "" : "";
      const isFlow = isFlowchartLike(code);

      const target = e && e.target ? e.target : null;
      const hasClosest = !!(target && target.closest);

      const edgeHit = hasClosest
        ? target.closest("g.edgeLabel") || target.closest("g.edgePath")
        : null;
      const node = hasClosest ? target.closest("g.node") : null;
      const textEl = hasClosest ? getEditableTextElementFromTarget(target) : null;
      if (!edgeHit && !node && !textEl) return;

      if (!isFlow) {
        if (!textEl) return;
        e.preventDefault();
        e.stopPropagation();
        const currentText = getTextFromSvgTextElement(textEl);
        promptTextAsync({
          title: "ラベルを編集",
          value: currentText,
          placeholder: "Label text",
          hint: "この編集は現在のプレビュー表示に反映されます。",
        }).then((nextText) => {
          if (nextText == null) return;
          const sanitized = sanitizeInlineSvgText(nextText);
          if (!sanitized) return;
          setTextOnSvgTextElement(textEl, sanitized);
        });
        return;
      }

      if (edgeHit) {
        e.preventDefault();
        e.stopPropagation();
        const ep = getFlowchartEdgeEndpointsFromSvg(target, code);
        if (!ep) {
          showToast("error", "エッジの接続先を取得できませんでした。別の箇所をクリックしてください。", {
            timeoutMs: 2200,
          });
          return;
        }
        let currentLabel =
          edgeHit.querySelector && edgeHit.querySelector("text")
            ? String(edgeHit.querySelector("text").textContent || "").trim()
            : "";
        if (!currentLabel && code) {
          const sameEdges = parseFlowchartEdgesFromCode(code).filter(
            (edge) => edge.from === ep.from && edge.to === ep.to
          );
          if (sameEdges.length === 1) {
            currentLabel = String(sameEdges[0].label || "").trim();
          }
        }
        if (e.altKey) {
          confirmAsync(ep.from + " → " + ep.to + " を削除しますか？", "エッジ削除").then(
            (ok) => {
              if (!ok) return;
              const latestCode = codeEl ? codeEl.value || "" : code;
              const removed = removeFlowchartEdge(
                latestCode,
                ep.from,
                ep.to,
                currentLabel
              );
              if (!removed.removed) {
                showToast("error", "エッジを削除できませんでした", { timeoutMs: 1800 });
                return;
              }
              if (codeEl) codeEl.value = removed.code;
              scheduleRenderDiagram(false);
            }
          );
          return;
        }
        promptTextAsync({
          title:
            typeof t === "function"
              ? t("editEdgeLabelTitle")
              : "Edit edge label",
          value: currentLabel,
          placeholder:
            typeof t === "function"
              ? t("edgeLabelPlaceholder")
              : "Edge label (optional)",
          hint:
            typeof t === "function"
              ? t("emptyMakesNoLabel") + " /delete: エッジ削除 " + t("submitHint")
              : "Leave empty to remove the label. Type /delete to delete the edge. Press Ctrl/Cmd+Enter to submit.",
        }).then((next) => {
          if (next == null) return;
          const rawNext = String(next).trim();
          if (/^\/delete$/i.test(rawNext)) {
            confirmAsync(ep.from + " → " + ep.to + " を削除しますか？", "エッジ削除").then(
              (ok) => {
                if (!ok) return;
                const latestCode = codeEl ? codeEl.value || "" : code;
                const removed = removeFlowchartEdge(
                  latestCode,
                  ep.from,
                  ep.to,
                  currentLabel
                );
                if (!removed.removed) {
                  showToast("error", "エッジを削除できませんでした", {
                    timeoutMs: 1800,
                  });
                  return;
                }
                if (codeEl) codeEl.value = removed.code;
                scheduleRenderDiagram(false);
              }
            );
            return;
          }
          const latestCode = codeEl ? codeEl.value || "" : code;
          const updated = upsertFlowchartEdge(
            latestCode,
            ep.from,
            ep.to,
            next,
            currentLabel
          );
          if (codeEl) codeEl.value = updated;
          scheduleRenderDiagram(false);
        });
        return;
      }

      e.preventDefault();
      e.stopPropagation();

      const nodeId = getFlowchartNodeId(node);
      if (!nodeId) {
        showToast("error", "ノードIDを取得できませんでした。", {
          timeoutMs: 2200,
        });
        return;
      }

      if (flowEdgeEdits.addMode) {
        if (!flowEdgeEdits.from) {
          flowEdgeEdits.from = nodeId;
          showToast("info", "接続先ノードを選択してください", {
            timeoutMs: 1600,
          });
          return;
        }
        const from = flowEdgeEdits.from;
        const to = nodeId;
        flowEdgeEdits.from = null;
        if (from === to) {
          showToast("info", "同じノードは選べません", { timeoutMs: 1400 });
          return;
        }
        promptTextAsync({
          title: typeof t === "function" ? t("addEdgeTitle") : "Add edge",
          value: "",
          placeholder:
            typeof t === "function"
              ? t("edgeLabelPlaceholder")
              : "Edge label (optional)",
          hint: from + " → " + to,
        }).then((label) => {
          if (label == null) return;
          const latestCode = codeEl ? codeEl.value || "" : code;
          const updated = upsertFlowchartEdge(latestCode, from, to, label);
          if (codeEl) codeEl.value = updated;
          scheduleRenderDiagram(false);
        });
        return;
      }

      const currentLabel = getNodeLabelFromSvgNode(node);
      promptTextAsync({
        title:
          typeof t === "function" ? t("editNodeLabelTitle") : "Edit node label",
        value: currentLabel,
        placeholder:
          typeof t === "function" ? t("nodeLabelPlaceholder") : "Node label",
        hint:
          typeof t === "function"
            ? t("submitHint")
            : "Press Ctrl/Cmd+Enter to submit.",
      }).then((nextLabel) => {
        if (nextLabel == null) return;
        const trimmed = sanitizeInlineLabel(nextLabel);
        if (!trimmed) return;
        const updated = replaceFlowchartNodeLabel(code, nodeId, trimmed);
        if (codeEl) codeEl.value = updated;
        scheduleRenderDiagram(false);
      });
    });
  }

  function getNodeLabelFromSvgNode(node) {
    var textEl = node.querySelector ? node.querySelector("text") : null;
    return (
      textEl && textEl.textContent ? String(textEl.textContent) : ""
    ).trim();
  }

  function getEditableTextElementFromTarget(target) {
    if (!target || !target.closest) return null;
    if (target.tagName && String(target.tagName).toLowerCase() === "text")
      return target;
    if (target.tagName && String(target.tagName).toLowerCase() === "tspan") {
      const p = target.parentElement;
      if (p && p.tagName && String(p.tagName).toLowerCase() === "text")
        return p;
    }
    return target.closest("text");
  }

  function getTextFromSvgTextElement(textEl) {
    if (!textEl) return "";
    const tspans = textEl.querySelectorAll
      ? Array.prototype.slice.call(textEl.querySelectorAll("tspan"))
      : [];
    if (tspans.length) {
      return tspans
        .map((x) => String((x && x.textContent) || ""))
        .join("\n")
        .trim();
    }
    return String(textEl.textContent || "").trim();
  }

  function sanitizeInlineSvgText(text) {
    let s = String(text == null ? "" : text);
    s = s.replace(/\uFEFF/g, "");
    s = s.replace(/\r/g, "");
    s = s.replace(/\n+/g, " ");
    s = s.replace(/\t/g, " ");
    s = s.replace(/\u0000/g, "");
    s = s.replace(/\s+/g, " ");
    if (s.length > 400) s = s.slice(0, 400);
    return s.trim();
  }

  function setTextOnSvgTextElement(textEl, label) {
    if (!textEl) return;
    var svgNS = "http://www.w3.org/2000/svg";
    var lines = String(label == null ? "" : label).split("\r").join("").split("\n");
    var tspans = textEl.querySelectorAll
      ? Array.prototype.slice.call(textEl.querySelectorAll("tspan"))
      : [];

    var baseX = textEl.getAttribute ? textEl.getAttribute("x") : null;
    if ((baseX == null || baseX === "") && tspans.length) {
      var tx = tspans[0].getAttribute ? tspans[0].getAttribute("x") : null;
      if (tx != null && tx !== "") baseX = tx;
    }
    var dy = "1.2em";
    if (tspans.length > 1) {
      var dy1 = tspans[1].getAttribute ? tspans[1].getAttribute("dy") : null;
      if (dy1) dy = dy1;
    } else if (tspans.length === 1) {
      var dy0 = tspans[0].getAttribute ? tspans[0].getAttribute("dy") : null;
      if (dy0) dy = dy0;
    }

    var template = tspans.length ? tspans[0].cloneNode(false) : null;

    while (textEl.firstChild) textEl.removeChild(textEl.firstChild);

    if (lines.length <= 1) {
      if (template) {
        if (baseX != null && baseX !== "") template.setAttribute("x", baseX);
        template.removeAttribute("dy");
        template.textContent = lines[0] || "";
        textEl.appendChild(template);
      } else {
        textEl.textContent = lines[0] || "";
      }
      return;
    }

    for (var i = 0; i < lines.length; i++) {
      var tspan = template
        ? template.cloneNode(false)
        : document.createElementNS(svgNS, "tspan");
      if (baseX != null && baseX !== "") tspan.setAttribute("x", baseX);
      if (i === 0) tspan.removeAttribute("dy");
      if (i > 0) tspan.setAttribute("dy", dy);
      tspan.textContent = lines[i];
      textEl.appendChild(tspan);
    }
  }

  function setNodeLabelOnSvgNode(node, label) {
    var textEls = node.querySelectorAll ? node.querySelectorAll("text") : [];
    for (var i = 0; i < textEls.length; i++) {
      setTextOnSvgTextElement(textEls[i], label);
    }
  }

  function applyResponsiveLayout(rawCode) {
    const normalized = (rawCode || "").trim();
    if (!normalized) return rawCode;

    const mode = getLayoutMode();
    const target = mode === "lr" ? "LR" : "TD";
    const firstInfo = getFirstDiagramLineInfo(normalized);
    const firstLine = firstInfo.line;

    // flowchart/graph (Mermaid v10+)
    if (/^(flowchart|graph)\b/i.test(firstLine)) {
      if (/^(flowchart|graph)\s+(TB|TD|BT|RL|LR)\b/im.test(normalized)) {
        return normalized.replace(
          /^(flowchart|graph)\s+(TB|TD|BT|RL|LR)\b/im,
          function (_, kw) {
            return kw + " " + target;
          }
        );
      }
      return normalized.replace(/^(flowchart|graph)\b/im, function (_, kw) {
        return kw + " " + target;
      });
    }

    // stateDiagram-v2 uses "direction LR" inside the block
    if (/^stateDiagram(-v2)?\b/i.test(firstLine)) {
      if (/^\s*direction\s+(TB|TD|BT|RL|LR)\b/im.test(normalized)) {
        return normalized.replace(
          /^\s*direction\s+(TB|TD|BT|RL|LR)\b/im,
          "direction " + target
        );
      }
      const lines = normalized.split(/\r?\n/);
      const insertAt =
        firstInfo.index >= 0 ? Math.min(lines.length, firstInfo.index + 1) : 1;
      lines.splice(insertAt, 0, "direction " + target);
      return lines.join("\n");
    }

    return rawCode;
  }

  function getFirstDiagramLineInfo(code) {
    const lines = String(code || "").split(/\r?\n/);
    for (let i = 0; i < lines.length; i++) {
      const trimmed = lines[i].trim();
      if (!trimmed) continue;
      if (trimmed.startsWith("%%")) continue; // comments / init directive
      return { line: trimmed, index: i };
    }
    return { line: "", index: -1 };
  }

  function getMermaidConfig(theme) {
    const selected = theme || "dark";
    const palette = getPalette();
    const codeEl = document.getElementById("mermaidCode");
    const isFlow = isFlowchartLike(codeEl ? codeEl.value || "" : "");

    function pickTextColor(hex) {
      const raw = String(hex || "")
        .trim()
        .toLowerCase();
      const m = raw.match(/^#([0-9a-f]{6})$/i);
      if (!m) return "#111827";
      const n = parseInt(m[1], 16);
      const r = (n >> 16) & 255;
      const g = (n >> 8) & 255;
      const b = n & 255;
      const luminance = (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255;
      return luminance < 0.55 ? "#ffffff" : "#111827";
    }

    const nodeText = pickTextColor(palette.node);
    const paletteVars = isFlow
      ? {
        primaryColor: palette.node,
        primaryBorderColor: palette.node,
        lineColor: palette.edge,
        primaryTextColor: nodeText,
      }
      : {};
    const themeCSS = isFlow
      ? ".node rect,.node polygon,.node circle,.node ellipse,.node path{fill:" +
      palette.node +
      " !important;stroke:" +
      palette.node +
      " !important;}" +
      ".node .label text,.nodeLabel{fill:" +
      nodeText +
      " !important;}" +
      ".edgePath path,.flowchart-link{stroke:" +
      palette.edge +
      " !important;}" +
      "marker path,.arrowheadPath{fill:" +
      palette.edge +
      " !important;stroke:" +
      palette.edge +
      " !important;}"
      : "";
    const commonThemeVariables = {
      fontFamily: "Arial, system-ui, -apple-system, Segoe UI, sans-serif",
      ...paletteVars,
    };

    const normalized = normalizeDiagramTheme(selected);
    return {
      startOnLoad: false,
      theme: normalized,
      themeVariables: commonThemeVariables,
      themeCSS: themeCSS,
      flowchart: {
        htmlLabels: false,
      },
    };
  }

  function isFlowchartLike(code) {
    const firstLine = getFirstDiagramLineInfo(code).line;
    return /^(flowchart|graph)\b/i.test(firstLine);
  }

  function showLoading(show, text = "Loading...") {
    const overlay = document.getElementById("loadingOverlay");
    const txt = document.getElementById("loadingText");
    if (show) {
      txt.innerText = text;
      overlay.classList.remove("hidden");
    } else {
      overlay.classList.add("hidden");
    }
  }

  let stickyCanvasErrorToast = null;
  function showCanvasError(message) {
    clearCanvasError();
    stickyCanvasErrorToast = showToast("error", String(message || ""), {
      timeoutMs: 0,
    });
  }
  function clearCanvasError() {
    if (stickyCanvasErrorToast && stickyCanvasErrorToast.parentNode)
      stickyCanvasErrorToast.remove();
    stickyCanvasErrorToast = null;
  }

  function applyTemplate(kind) {
    const lang = typeof getCurrentLang === "function" ? getCurrentLang() : "ja";
    const promptEl = document.getElementById("userInput");
    const typeEl = document.getElementById("diagramTypeSelect");
    const codeEl = document.getElementById("mermaidCode");
    if (!promptEl || !typeEl) return;

    const templates = {
      flowchart: {
        type: "flowchart TD",
        ja: "ユーザー登録のフローを図にしてください。\n入力 → 確認 → 保存 → 完了。エラー時は入力に戻る。",
        en: "Draw a user signup flow.\nInput → Confirm → Save → Done. On error, go back to Input.",
        code: "flowchart TD\n  A[Start] --> B{Valid?}\n  B -->|Yes| C[Save]\n  C --> D[Done]\n  B -->|No| E[Fix input]\n  E --> B",
      },
      sequence: {
        type: "sequenceDiagram",
        ja: "ログイン処理のシーケンス図。\n登場人物: User, Browser, API。\n成功/失敗の分岐も入れて。",
        en: "Sequence diagram for login.\nParticipants: User, Browser, API.\nInclude success/failure branches.",
        code: "sequenceDiagram\n  participant U as User\n  participant B as Browser\n  participant A as API\n  U->>B: Enter credentials\n  B->>A: POST /login\n  alt success\n    A-->>B: 200 OK (token)\n    B-->>U: Logged in\n  else failure\n    A-->>B: 401 Unauthorized\n    B-->>U: Show error\n  end",
      },
      mindmap: {
        type: "mindmap",
        ja: "新規プロジェクト計画のマインドマップ。\n目的 / タスク / リスク / マイルストーン。",
        en: "Mindmap for a new project plan.\nGoals / Tasks / Risks / Milestones.",
        code: "mindmap\n  root((Project))\n    Goals\n      Success metrics\n    Tasks\n      MVP\n      Launch\n    Risks\n      Schedule\n      Scope\n    Milestones\n      Week 1\n      Week 4\n      Week 8",
      },
      gantt: {
        type: "gantt",
        ja: "プロジェクトの簡単なガントチャートを作成してください。\nフェーズと担当、期間も入れて。",
        en: "Create a simple project Gantt chart.\nInclude phases, owners, and dates.",
        code: "gantt\n  title Project Plan\n  dateFormat  YYYY-MM-DD\n  section Phase 1\n  Research         :a1, 2025-01-01, 7d\n  Design           :a2, after a1, 5d\n  section Phase 2\n  Implementation   :b1, after a2, 10d\n  Testing          :b2, after b1, 5d",
      },
    };

    const t = templates[kind] || templates.flowchart;
    typeEl.value = t.type;
    promptEl.value = lang === "en" ? t.en : t.ja;
    if (typeof togglePanel === "function") togglePanel(true);
    if (typeof setSideTab === "function") setSideTab("create");
    promptEl.focus();
    syncAppStateFromInputs();
    if (codeEl && t.code) {
      codeEl.value = t.code;
      Promise.resolve(renderDiagram(false)).catch(() => { });
    }
    const msg =
      lang === "en"
        ? "Template applied. Edit if needed, then click Generate."
        : "テンプレートをセットしました。必要なら編集して「生成する」を押してください。";
    showToast("success", msg);
  }

  function downloadMD() {
    const codeEl = document.getElementById("mermaidCode");
    const raw = codeEl ? codeEl.value : "";
    const safe = repairCommonSyntaxErrors(String(raw || ""));
    if (!safe) return;
    if (codeEl) codeEl.value = safe;
    downloadFile(safe, "diagram.md", "text/markdown");
  }
  function downloadSVG() {
    const svgElement = document.querySelector("#diagram-output svg");
    if (!svgElement) {
      showToast("info", "図が描画されていません");
      return;
    }
    const svgData = new XMLSerializer().serializeToString(svgElement);
    downloadFile(svgData, "diagram.svg", "image/svg+xml;charset=utf-8");
  }
  async function copyTextToClipboard(text) {
    const value = String(text == null ? "" : text);
    if (navigator.clipboard && window.isSecureContext) {
      await navigator.clipboard.writeText(value);
      return;
    }
    const ta = document.createElement("textarea");
    ta.value = value;
    ta.setAttribute("readonly", "true");
    ta.style.position = "fixed";
    ta.style.left = "-9999px";
    ta.style.top = "0";
    document.body.appendChild(ta);
    ta.focus();
    ta.select();
    const ok = document.execCommand("copy");
    document.body.removeChild(ta);
    if (!ok) throw new Error("copy failed");
  }

  function buildGeminiImagePrompt(mermaidCode) {
    // Backward-compatible wrapper; actual prompt is built by `buildGeminiImagePromptCompiled`.
    const code = String(mermaidCode == null ? "" : mermaidCode);
    const styleId =
      localStorage.getItem("diagram.imagePrompt.styleId") || "business";
    const styleCustom =
      localStorage.getItem("diagram.imagePrompt.custom." + styleId) || "";
    const extraNegatives =
      localStorage.getItem("diagram.imagePrompt.negatives") || "";
    const userEl = document.getElementById("userInput");
    const userText = userEl ? String(userEl.value || "").trim() : "";
    return buildGeminiImagePromptCompiled(
      code,
      { styleId, styleCustom, extraNegatives },
      userText
    );
  }

  function extractExplicitTitleFromMermaid(code) {
    const src = String(code == null ? "" : code).replace(/\r/g, "");
    const patterns = [
      /^\s*(?:%%\s*)?title\s*:\s*["']?(.+?)["']?\s*$/gim,
      /^\s*(?:%%\s*)?title\s+["']?(.+?)["']?\s*$/gim,
    ];
    for (const re of patterns) {
      const m = re.exec(src);
      if (m && m[1]) {
        const t = String(m[1]).trim();
        if (t) return t;
      }
    }
    return null;
  }

  function extractTitleFromMermaid(code) {
    return extractExplicitTitleFromMermaid(code) || "プロセス構造図";
  }

  function extractTitleFromUserText(userText) {
    const src = String(userText == null ? "" : userText).replace(/\r/g, "");
    if (!src.trim()) return null;

    // Prefer explicit "title:" / "タイトル:" declaration in the user input.
    const m1 = /^\s*(?:title|タイトル)\s*[:：]\s*(.+?)\s*$/gim.exec(src);
    if (m1 && m1[1]) {
      const t = String(m1[1]).trim();
      if (t) return t;
    }

    // Otherwise, use the first non-empty line.
    const first =
      src
        .split("\n")
        .map((x) => x.trim())
        .filter(Boolean)[0] || "";
    if (!first) return null;

    // Strip leading markdown bullets/headers if present.
    const cleaned = first.replace(/^[-*#]+\s*/, "").trim();
    if (!cleaned) return null;

    // Soft cap to avoid absurdly long slide headers.
    const max = 60;
    return cleaned.length > max ? cleaned.slice(0, max) : cleaned;
  }

  function deriveSlideTitle(mermaidCode, userText) {
    const explicit = extractExplicitTitleFromMermaid(mermaidCode);
    if (explicit) return explicit;
    const fromUser = extractTitleFromUserText(userText);
    if (fromUser) return fromUser;
    return "プロセス構造図";
  }

  function extractMermaidFromText(text) {
    const src = String(text == null ? "" : text).replace(/\r/g, "");
    const fence = /```mermaid\s*([\s\S]*?)\s*```/i.exec(src);
    if (fence && fence[1]) return String(fence[1]).trim();

    const keywords = [
      "flowchart",
      "graph",
      "sequenceDiagram",
      "gantt",
      "stateDiagram-v2",
      "stateDiagram",
      "classDiagram",
      "erDiagram",
      "journey",
      "mindmap",
      "timeline",
      "pie",
      "gitGraph",
      "C4Context",
      "C4Container",
      "C4Component",
      "C4Dynamic",
      "C4Deployment",
    ];
    const re = new RegExp(
      "(^|\\n)\\s*(" +
      keywords
        .map((k) => k.replace(/[-/\\^$*+?.()|[\\]{}]/g, "\\$&"))
        .join("|") +
      ")\\b",
      "i"
    );
    const m = re.exec(src);
    if (m && typeof m.index === "number") {
      const start = src.indexOf(m[2], m.index);
      if (start >= 0) return src.slice(start).trim();
    }
    return src.trim();
  }

  function extractDirectionText(code) {
    const src = String(code == null ? "" : code).replace(/\r/g, "");
    const first =
      src
        .split("\n")
        .map((x) => x.trim())
        .filter(Boolean)[0] || "";
    const flow = /^(flowchart|graph)\s+([A-Za-z]{2})\b/.exec(first);
    if (flow && flow[2]) {
      const dir = String(flow[2]).toUpperCase();
      switch (dir) {
        case "LR":
          return "from left to right";
        case "RL":
          return "from right to left";
        case "TB":
          return "from top to bottom";
        case "TD":
          return "from top to bottom";
        case "BT":
          return "from bottom to top";
      }
    }
    const stateDir = /(^|\n)\s*direction\s+([A-Za-z]{2})\b/i.exec(src);
    if (stateDir && stateDir[2]) {
      const dir = String(stateDir[2]).toUpperCase();
      switch (dir) {
        case "LR":
          return "from left to right";
        case "RL":
          return "from right to left";
        case "TB":
          return "from top to bottom";
        case "TD":
          return "from top to bottom";
        case "BT":
          return "from bottom to top";
      }
    }
    return "with a clear directional flow";
  }

  function extractFlowDirectionText(code) {
    return extractDirectionText(code);
  }

  function stripOuterQuotes(text) {
    let s = String(text == null ? "" : text).trim();
    if (
      (s.startsWith('"') && s.endsWith('"')) ||
      (s.startsWith("'") && s.endsWith("'"))
    ) {
      s = s.slice(1, -1).trim();
    }
    return s;
  }

  function extractFlowchartNodes(code) {
    const src = String(code == null ? "" : code).replace(/\r/g, "");
    const lines = src.split("\n");
    const out = [];
    const openRe = /(^|\s)([A-Za-z0-9_]+)\s*(\[\[|\[\/|\[|\(\(|\(\[|\(|\{)/g;
    const closeMap = {
      "[[": "]]",
      "[/": "/]",
      "[": "]",
      "((": "))",
      "([": "])",
      "(": ")",
      "{": "}",
    };
    for (const line0 of lines) {
      const line = String(line0);
      const trimmed = line.trim();
      if (!trimmed) continue;
      if (/^(classDef|class|style|linkStyle)\b/.test(trimmed)) continue;
      if (/^%%/.test(trimmed)) continue;

      let m;
      openRe.lastIndex = 0;
      while ((m = openRe.exec(line))) {
        const id = m[2];
        const open = m[3];
        const close = closeMap[open];
        const start = openRe.lastIndex;
        const end = close ? line.indexOf(close, start) : -1;
        if (end === -1) continue;
        const raw = line.slice(start, end).trim();
        const label = stripOuterQuotes(raw).replace(/\\n/g, " ").trim();
        out.push({ id, label });
        openRe.lastIndex = end + close.length;
      }
    }
    return out;
  }

  function repairCommonSyntaxErrors(code) {
    let src = String(code || "");
    src = src.replace(/\r/g, "");
    src = src.replace(/\uFEFF/g, "");

    // Mindmap fallback:
    // If flowchart-like syntax is mixed into mindmap, convert to flowchart TD and continue repair.
    if (/^\s*mindmap\b/im.test(src) && (/\s-->\s/.test(src) || /^\s*subgraph\b/im.test(src))) {
      const mmLines = src.split("\n");
      const out = [];
      out.push("flowchart TD");
      for (let i = 0; i < mmLines.length; i++) {
        const line = String(mmLines[i] || "");
        if (/^\s*mindmap\b/i.test(line)) continue;
        if (/^\s*subgraph\b/i.test(line)) continue;
        if (/^\s*end\s*$/i.test(line)) continue;
        let cur = line;
        cur = cur.replace(/^\s*root\s*\(\((.+)\)\)\s*$/i, function (_, label) {
          return 'ROOT["' + String(label || "").replace(/\\+"/g, "'").replace(/"/g, "'").trim() + '"]';
        });
        out.push(cur);
      }
      src = out.join("\n");
    }

    // StateDiagram fallback:
    // Normalize flowchart-like node decorations and unsupported styled arrows.
    if (/^\s*stateDiagram-v2\b/im.test(src)) {
      const stLines = src.split("\n");
      const stateAlias = new Map(); // id -> label
      const declaredCompositeStates = new Set();
      const cleaned = [];
      for (let i = 0; i < stLines.length; i++) {
        let line = String(stLines[i] || "");
        const cm = /^\s*state\s+([A-Za-z_][A-Za-z0-9_]*)\s*\{/.exec(line);
        if (cm && cm[1]) declaredCompositeStates.add(String(cm[1]));
        // styled arrow like --[#red]-> is not supported in some Mermaid versions
        line = line.replace(/--\s*\[[^\]]*]\s*->/g, "-->");

        // Convert ID["Label"] / ID['Label'] / ID{"Label"} to ID and remember alias.
        line = line.replace(/([A-Za-z_][A-Za-z0-9_]*)\s*\[\s*"([^"]+)"\s*]/g, function (_, id, label) {
          stateAlias.set(String(id), String(label));
          return id;
        });
        line = line.replace(/([A-Za-z_][A-Za-z0-9_]*)\s*\[\s*'([^']+)'\s*]/g, function (_, id, label) {
          stateAlias.set(String(id), String(label));
          return id;
        });
        line = line.replace(/([A-Za-z_][A-Za-z0-9_]*)\s*\{\s*"([^"]+)"\s*}/g, function (_, id, label) {
          stateAlias.set(String(id), String(label));
          return id;
        });
        line = line.replace(/([A-Za-z_][A-Za-z0-9_]*)\s*\{\s*'([^']+)'\s*}/g, function (_, id, label) {
          stateAlias.set(String(id), String(label));
          return id;
        });
        line = line.replace(/([A-Za-z_][A-Za-z0-9_]*)\s*\{\s*([^}"']+)\s*}/g, function (_, id, label) {
          stateAlias.set(String(id), String(label));
          return id;
        });
        cleaned.push(line);
      }

      // Insert alias definitions right after diagram header.
      const withAliases = [];
      let inserted = false;
      for (let i = 0; i < cleaned.length; i++) {
        const line = cleaned[i];
        withAliases.push(line);
        if (!inserted && /^\s*stateDiagram-v2\b/i.test(line)) {
          inserted = true;
          stateAlias.forEach((label, id) => {
            if (id === "[*]") return;
            if (!id) return;
            if (declaredCompositeStates.has(id)) return;
            const safe = String(label || "").replace(/"/g, "'");
            withAliases.push('  state "' + safe + '" as ' + id);
          });
        }
      }
      src = withAliases.join("\n");
    }

    // pattern: subgraph["Title"] -> subgraph "Title"
    // reason: Gemini often outputs subgraph["..."] which is invalid Mermaid
    src = src.replace(/(\s*subgraph)\s*\["([^"]+)"\]:::([^\s]*)/gi, '$1 "$2"');
    src = src.replace(/(\s*subgraph)\s*\["([^"]+)"\]/gi, '$1 "$2"');
    src = src.replace(/(\s*subgraph)\s*\['([^']+)'\]/gi, "$1 '$2'");

    // Remove trailing ::: from lines (invalid style attachment to subgraph start)
    // e.g. subgraph "Title":::
    const lines = src.split('\n');
    let autoSubgraphId = 1;
    let isGantt = false;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];

      if (/^\s*gantt\b/i.test(line)) {
        isGantt = true;
      }

      if (/^\s*subgraph\b/i.test(line)) {
        let fixed = line.replace(/:::.*$/, '').replace(/:::\s*$/, '');
        const m1 = fixed.match(/^(\s*)subgraph\s*\["([^"]+)"\]\s*$/i);
        const m2 = fixed.match(/^(\s*)subgraph\s*\['([^']+)'\]\s*$/i);
        const m3 = fixed.match(/^(\s*)subgraph\s+"([^"]+)"\s*$/i);
        const m4 = fixed.match(/^(\s*)subgraph\s+'([^']+)'\s*$/i);
        if (m1) {
          const title = String(m1[2]).replace(/"/g, "'");
          fixed = `${m1[1]}subgraph SG${autoSubgraphId++}["${title}"]`;
        } else if (m2) {
          const title = String(m2[2]).replace(/"/g, "'");
          fixed = `${m2[1]}subgraph SG${autoSubgraphId++}["${title}"]`;
        } else if (m3) {
          const title = String(m3[2]).replace(/"/g, "'");
          fixed = `${m3[1]}subgraph SG${autoSubgraphId++}["${title}"]`;
        } else if (m4) {
          const title = String(m4[2]).replace(/"/g, "'");
          fixed = `${m4[1]}subgraph SG${autoSubgraphId++}["${title}"]`;
        }
        lines[i] = fixed;
      }

      // Gantt chart: Task names cannot contain colons unless it's the separator
      if (isGantt && line.includes(':')) {
        // Heuristic: The last colon is the separator if what follows looks like metadata
        // Metadata starts with: after, \d{4}-, \d+(d|h|m|s), active, done, crit, milestone
        const lastColon = line.lastIndexOf(':');
        if (lastColon > 0) {
          const pre = line.slice(0, lastColon);
          const post = line.slice(lastColon + 1);
          // Check if post looks like metadata
          if (/^\s*(after\s|[\d]{4}-|\d+(d|h|m|s)|active|done|crit|milestone|[a-zA-Z0-9]+,)/.test(post)) {
            // It is likely a separator. Replace colons in 'pre' with full-width colon
            const fixedPre = pre.replace(/:/g, '：');
            lines[i] = fixedPre + ':' + post;
          }
          // If post doesn't look like metadata, maybe the colon is just part of the title and there is NO metadata?
          // But Mermaid Gantt usually requires : to define metadata or at least to separate checking?
          // Actually, "Task Name" without colon is valid if no metadata?
          // If the line is "Task Name : ", then post is empty/whitespace.
          // Ideally we only touch lines that actually cause issues.
        }
      }
    }
    src = lines.join('\n');

    // Flowchart: normalize raw double-quotes inside square-bracket labels
    if (/^\s*(flowchart|graph)\b/im.test(src)) {
      src = src.replace(/([A-Za-z0-9_]+)\[(?!\[)((?:[^"\]]|"[^"]*")*)]/g, function (_, id, label) {
        let t = String(label == null ? "" : label).trim();
        if (!t) return id + '[""]';
        if (/^".*"$/.test(t)) {
          let inner = t.slice(1, -1);
          inner = inner.replace(/\\"+/g, "'").replace(/"/g, "'");
          inner = inner.replace(/'{2,}/g, "'");
          return id + '["' + inner + '"]';
        }
        return id + '["' + t.replace(/\\"+/g, "'").replace(/"/g, "'") + '"]';
      });
    }

    // Additional repair for ER diagrams: Attribute names must be ASCII
    // Pattern:
    // erDiagram
    //   ENTITY "Name" {
    //     type attributeName "comment"
    //     ...
    //   }
    if (/^\s*erDiagram/m.test(src)) {
      let attrCounter = 1;
      const erLines = src.split('\n');
      let inBlock = false;
      for (let i = 0; i < erLines.length; i++) {
        const line = erLines[i];
        if (line.includes('{')) inBlock = true;
        if (line.includes('}')) inBlock = false;

        if (inBlock && !line.includes('{') && !line.includes('}')) {
          // Expecting: type attributeName [PK|FK] ["comment"]
          // We want to target 'attributeName' if it has non-ASCII
          // Regex: space + type + space + attributeName + ...
          const match = line.match(/^\s*([a-zA-Z0-9_]+)\s+([^\s]+)(.*)$/);
          if (match) {
            const type = match[1];
            const name = match[2];
            const rest = match[3]; // includes remaining spaces, keys, comments

            // Check if name has non-ASCII
            if (/[^\x00-\x7F]/.test(name)) {
              const newName = "attr_" + (attrCounter++);
              // If 'rest' already has a comment string, use that? 
              // Or if not, use original name as comment?
              // The user's error showed: string カテゴリ "カテゴリ" -> name is カテゴリ, rest is " "カテゴリ"

              // If rest contains a quoted string, we might keep it.
              // But if the name itself was Japanese, we should probably output: type attr_N "OriginalName"

              // Let's allow existing comments to stay if they exist, but if not, verify.
              // Actually, easiest is: replace name with newName. 
              // If 'rest' does NOT have a comment, append "OriginalName".
              // If 'rest' HAS a comment, we keep it.

              let newLine = line.replace(name, newName);
              if (!/"[^"]*"/.test(rest) && !/'[^']*'/.test(rest)) {
                newLine += ' "' + name + '"';
              }
              erLines[i] = newLine;
            }
          }
        }
      }
      src = erLines.join('\n');
    }

    // Additional repair for gitGraph:
    // branch Name -> branch "Name" (if not already quoted)
    // checkout Name -> checkout "Name"
    // merge Name -> merge "Name"
    // Additional repair for gitGraph:
    // Remove direction specifiers like "TD", "TB", "LR" which are invalid for gitGraph in some versions
    if (/^\s*gitGraph/m.test(src)) {
      src = src.replace(/^(\s*gitGraph)\s+(TD|TB|BT|LR|RL)\b/im, '$1');

      const gitLines = src.split('\n');

      for (let i = 0; i < gitLines.length; i++) {
        let line = gitLines[i];
        if (/^\s*(branch|checkout|merge)\s/.test(line)) {
          line = line.replace(/^(\s*(?:branch|checkout|merge))\s+([^":\n\r]+?)(\s*)$/i, function (m, cmd, name, suffix) {
            const trimmed = name.trim();
            if (trimmed.startsWith('"') && trimmed.endsWith('"')) return m;
            if (trimmed.startsWith("'") && trimmed.endsWith("'")) return m;
            const escaped = trimmed.replace(/"/g, '\\"');
            return `${cmd} "${escaped}"${suffix}`;
          });
          gitLines[i] = line;
        }
      }
      src = gitLines.join('\n');
    }

    // Additional repair for journey:
    if (/^\s*journey/m.test(src)) {
      const jLines = src.split('\n');
      for (let i = 0; i < jLines.length; i++) {
        let line = jLines[i].trim();
        if (!line || /^(journey|title|section)\b/i.test(line)) continue;
        const parts = line.split(':');
        if (parts.length > 3) {
          const status = parts.pop().trim();
          const score = parts.pop().trim();
          const taskName = parts.join(' ').trim();
          jLines[i] = `      ${taskName} : ${score} : ${status}`;
        }
      }
      src = jLines.join('\n');
    }

    // Additional repair for C4Context:
    if (/^\s*(C4Context|C4Container|C4Component)/m.test(src)) {
      const c4Lines = src.split('\n');
      for (let i = 0; i < c4Lines.length; i++) {
        // Comment out "note" or "Note(" lines as they cause lexical errors in C4
        if (/^\s*Note\s*(?:\(|\b(?:left|right|over)\b)/i.test(c4Lines[i])) {
          c4Lines[i] = "%% " + c4Lines[i];
        }
      }
      src = c4Lines.join('\n');
    }

    return src;
  }

  function iconForNodeLabel(label, id) {
    const s = (String(label || "") + " " + String(id || "")).toLowerCase();
    const has = (re) => re.test(s);
    if (has(/\b(start|begin)\b|開始/)) return "a start/play icon";
    if (has(/\b(end|done|finish)\b|完了|終了/)) return "a checkmark/done icon";
    if (has(/\buser|client\b|ユーザー|利用者/))
      return "a person icon for the user";
    if (has(/\b(system|server|backend)\b|システム/))
      return "a gear icon for the system";
    if (has(/\bregex\b|正規表現/))
      return "a magnifying glass icon (regex extraction)";
    if (has(/\bdb\b|\bdatabase\b|データベース/))
      return "a database cylinder icon";
    if (has(/\bstyle\b|スタイル/)) return "a paint palette icon (style module)";
    if (has(/\bparam\b|parameter|パラメータ/))
      return "a sliders icon (parameters)";
    if (has(/\bnegative\b|constraint|制約|禁止|ネガ/))
      return "a ban icon (negative constraints)";
    if (has(/\bbuilder\b|compile|compiler|prompt|プロンプト|組立/))
      return "a blocks/documents icon (prompt builder)";
    // Avoid treating "Gemini/Google site" as an AI/LLM concept.
    if (has(/\bllm\b|\bgpt\b|\bcompiler\b/))
      return "an AI chip icon (LLM compiler)";
    if (has(/\bimage\b|imggen|生成|画像/))
      return "an image/photo icon (image generator)";
    if (has(/security|secure|csp|ブロック|高セキュリティ|銀行|鍵|ロック/))
      return "a shield/lock icon (security)";
    if (has(/manual|hand|手動|編集/)) return "a hand/edit icon (manual action)";
    if (has(/site|web|browser|サイト|web|ブラウザ/))
      return "a browser/window icon (website)";
    return "a simple geometric node icon";
  }

  function extractStateDiagramLabels(code) {
    const src = String(code == null ? "" : code).replace(/\r/g, "");
    const lines = src.split("\n");
    const aliasToLabel = new Map();
    const labels = [];

    for (const line0 of lines) {
      const line = String(line0).trim();
      if (!line) continue;
      // state "Label" as ID {
      const m = /^state\s+"([^"]+)"\s+as\s+([A-Za-z0-9_]+)\b/i.exec(line);
      if (m && m[1] && m[2]) {
        const lbl = String(m[1]).trim();
        const id = String(m[2]).trim();
        if (lbl) {
          aliasToLabel.set(id, lbl);
          labels.push(lbl);
        }
        continue;
      }
    }

    for (const line0 of lines) {
      const line = String(line0).trim();
      if (!line) continue;
      if (/^state\s+\"/.test(line)) continue;
      if (/^direction\b/i.test(line)) continue;

      const arrow = /(.+?)\s*-->\s*(.+?)(?:\s*:\s*(.+))?$/.exec(line);
      if (!arrow) continue;
      const fromRaw = String(arrow[1]).trim();
      const toRaw = String(arrow[2]).trim();
      const from =
        fromRaw === "[*]" ? "" : aliasToLabel.get(fromRaw) || fromRaw;
      const to = toRaw === "[*]" ? "" : aliasToLabel.get(toRaw) || toRaw;
      if (from) labels.push(from);
      if (to) labels.push(to);
    }

    // Unique, keep order
    const seen = new Set();
    const out = [];
    for (const x of labels) {
      const s = String(x).trim();
      if (!s) continue;
      if (seen.has(s)) continue;
      seen.add(s);
      out.push(s);
      if (out.length >= 30) break;
    }
    return out;
  }

  function buildIconDescriptionFromMermaid(code) {
    const nodes = extractFlowchartNodes(code);
    if (!nodes.length) {
      const stateLabels = extractStateDiagramLabels(code);
      if (!stateLabels.length)
        return "simple abstract icons for each step (no text labels)";
      const seen = new Set();
      const parts = [];
      for (const lbl of stateLabels) {
        const icon = iconForNodeLabel(lbl, "");
        if (seen.has(icon)) continue;
        seen.add(icon);
        parts.push(icon);
        if (parts.length >= 8) break;
      }
      return parts.length
        ? parts.join(", ")
        : "simple abstract icons for each step (no text labels)";
    }
    const seen = new Set();
    const parts = [];
    for (const n of nodes) {
      const icon = iconForNodeLabel(n.label, n.id);
      if (seen.has(icon)) continue;
      seen.add(icon);
      parts.push(icon);
      if (parts.length >= 8) break;
    }
    return parts.length
      ? parts.join(", ")
      : "simple abstract icons for each step (no text labels)";
  }

  function buildGeminiImagePromptCompiled(
    mermaidCode,
    settings,
    userDescription
  ) {
    const code = extractMermaidFromText(mermaidCode).trim();
    const opts = settings && typeof settings === "object" ? settings : {};
    const langSetting = String(opts.lang || "auto");
    const uiLang = localStorage.getItem(UI_LANG_KEY) || "ja";
    const lang =
      langSetting === "ja" || langSetting === "en"
        ? langSetting
        : uiLang === "en"
          ? "en"
          : "ja";
    const styleId = String(opts.styleId || "business");
    const style = IMAGE_STYLE_MODULES[styleId] || IMAGE_STYLE_MODULES.business;
    const slideTitle = deriveSlideTitle(code, userDescription);
    const dirText = extractFlowDirectionText(code);
    const iconDesc = buildIconDescriptionFromMermaid(code);
    const intent = String(
      userDescription == null ? "" : userDescription
    ).trim();

    const styleText = String(style.prompt || "").trim();
    const styleCustom = String(opts.styleCustom || "").trim();
    const mergedStyle = styleCustom ? styleText + " " + styleCustom : styleText;

    const maxMermaidChars = 9000;
    const mermaidForPrompt =
      code.length > maxMermaidChars
        ? code.slice(0, maxMermaidChars) + "\n... (truncated)"
        : code;

    const baseNegatives = [
      "No gibberish text. No random placeholder words.",
      "Do NOT render any prompt/meta labels such as: INPUT DESCRIPTION, INPUT DESCRIPTION SUMMARY, STRUCTURE SOURCE, LANGUAGE ENFORCEMENT, NEGATIVE CONSTRAINTS, TITLE RULE, Icons suggestion, Slide layout.",
      "Do NOT render the instruction text of this prompt. Render only content derived from the Mermaid diagram and the user intent (topic facts), not the tool instructions.",
      "Do not use generic titles like 'Future of AI'.",
      "No blurry text. No tiny unreadable text.",
    ];
    if (lang === "ja") {
      baseNegatives.push(
        "No English text. Do not translate Japanese into English."
      );
      baseNegatives.push(
        "Avoid URLs and long Latin strings unless they appear in the Mermaid diagram or user input as required content."
      );
    } else {
      baseNegatives.push(
        "No Japanese text unless it comes verbatim from the input. Do not translate Japanese into English without permission."
      );
    }
    const styleNeg = String(IMAGE_STYLE_NEGATIVES[styleId] || "").trim();
    const extraNeg = String(opts.extraNegatives || "").trim();
    const negJoined = baseNegatives
      .concat(styleNeg ? [styleNeg] : [])
      .concat(extraNeg ? [extraNeg] : [])
      .join(" ");

    const suffix = "high resolution, 8k, sharp focus, aesthetic composition";

    return [
      `A high-quality ${mergedStyle}`,
      intent
        ? `REFERENCE (for understanding only; do NOT render this text verbatim): """\n${intent}\n"""`
        : "",
      `REFERENCE (Mermaid code for understanding only; do NOT render this text verbatim): """\n${mermaidForPrompt}\n"""`,
      `DIAGRAM FIDELITY (highest priority): The Mermaid code is the blueprint. Render a clean diagram/infographic that matches the Mermaid structure exactly: include every node and every edge; preserve branches/merges; preserve subgraph groupings as separate containers with titles; follow the declared direction (${dirText}).`,
      `TEXT FIDELITY: Copy node labels, decision labels, and subgraph titles from the Mermaid code VERBATIM. Do not translate, do not paraphrase, do not summarize Mermaid labels. Do not invent any new labels that are not present in the Mermaid or the user intent.`,
      `Text rendering: render readable labels for nodes, decisions, and subgraph titles. Use ${lang === "ja" ? "Japanese" : "English"
      } as the primary language.`,
      `MANGA STYLE ADAPTER (important): Apply manga ink aesthetics to the diagram (linework, screentone shading, panel borders), but keep it strictly a diagram. No characters, no narrative scenes, no product photos, no cinematic perspective. Speech bubbles may be used ONLY for the header title; all other text must be inside simple diagram boxes.`,
      `Slide layout: wide 16:9. Use a clean slide composition: (1) a prominent header title '${slideTitle}', (2) a central diagram area that follows the Mermaid structure, and (3) optional side panels with short bullet points summarizing only topic facts from the user intent (e.g., 概要 / 要点). Do not add facts not present in the Mermaid or user intent. Do NOT use headings like "INPUT DESCRIPTION" or "SUMMARY".`,
      `Visual system: consistent icon set, consistent stroke weight, clear arrowheads, aligned grid, generous whitespace. Icons suggestion: ${iconDesc}.`,
      lang === "ja"
        ? `LANGUAGE ENFORCEMENT: Output language is Japanese. Do not translate Japanese to English. If the model accidentally outputs text, it must be Japanese.`
        : `LANGUAGE ENFORCEMENT: Output language is English. If the model accidentally outputs text, it must be English (except the main title which must be exact).`,
      `TITLE RULE: The slide must prominently display the header title exactly as provided: '${slideTitle}'.`,
      `NEGATIVE CONSTRAINTS: ${negJoined}`,
      suffix,
    ]
      .filter(Boolean)
      .join(" ");
  }

  let lastExternalOpenAt = 0;
  let lastExternalOpenUrl = "";
  function openInNewTab(url) {
    const u = String(url || "");
    if (!u) return false;
    const now = Date.now();
    if (u && lastExternalOpenUrl === u && now - lastExternalOpenAt < 2000)
      return true;
    lastExternalOpenAt = now;
    lastExternalOpenUrl = u;

    // 0) Apps Script host API (if available in this container).
    try {
      if (
        window.google &&
        google.script &&
        google.script.host &&
        typeof google.script.host.openLink === "function"
      ) {
        google.script.host.openLink(u);
        return true;
      }
    } catch (_) { }

    // 1) Try native popup first (works in normal browsers if user activation is preserved).
    try {
      const w = window.open(u, "_blank", "noopener,noreferrer");
      if (w) return true;
    } catch (_) { }

    // 2) Best effort: synthetic link click to _blank.
    // Note: this method has no reliable success signal on mobile browsers.
    try {
      const aBlank = document.createElement("a");
      aBlank.href = u;
      aBlank.target = "_blank";
      aBlank.rel = "noopener noreferrer";
      document.body.appendChild(aBlank);
      aBlank.click();
      window.setTimeout(() => aBlank.remove(), 80);
    } catch (_) { }

    // 3) Best effort: ask browser to navigate top frame via anchor.
    // This avoids popup blockers on Android Chrome + Apps Script iframe environments.
    try {
      const aTop = document.createElement("a");
      aTop.href = u;
      aTop.target = "_top";
      aTop.rel = "noopener noreferrer";
      document.body.appendChild(aTop);
      aTop.click();
      window.setTimeout(() => aTop.remove(), 80);
    } catch (_) { }

    // 4) Final fallback to direct location assignment.
    try {
      if (window.top && window.top.location) {
        window.top.location.assign(u);
        return true;
      }
    } catch (_) { }
    try {
      window.location.assign(u);
      return true;
    } catch (_) {
      return false;
    }
  }

  async function openGeminiAppWithFallbackNotice() {
    const url = "https://gemini.google.com/app";
    const opened = openInNewTab(url);
    if (opened) return;
    try {
      await copyTextToClipboard(url);
    } catch (_) { }
    showToast(
      "info",
      "Geminiを自動で開けませんでした。URLはコピー済みです。ブラウザに貼り付けて開いてください。",
      { timeoutMs: 4200 }
    );
  }

  let geminiImagePromptBusy = false;
  async function copyGeminiImagePrompt() {
    if (geminiImagePromptBusy) return;
    geminiImagePromptBusy = true;
    const codeEl = document.getElementById("mermaidCode");
    const code = codeEl ? String(codeEl.value || "").trim() : "";
    if (!code) {
      showToast("info", t("geminiImageEmpty"));
      geminiImagePromptBusy = false;
      return;
    }

    try {
      const settings = await promptImagePromptSettingsAsync();
      if (!settings) return;

      const userEl = document.getElementById("userInput");
      const userText = userEl ? String(userEl.value || "").trim() : "";
      const prompt = buildGeminiImagePromptCompiled(code, settings, userText);
      await copyTextToClipboard(prompt);
      showToast("success", t("geminiImageCopied"));

      await confirmAsyncWithOkAction(t("geminiOpenConfirm"), "Gemini", () => {
        openGeminiAppWithFallbackNotice();
      });
    } catch (e) {
      showToast(
        "error",
        "コピーに失敗しました: " + (e && e.message ? e.message : e)
      );
      return;
    } finally {
      geminiImagePromptBusy = false;
    }
  }

  async function downloadPNG() {
    const svgElement = document.querySelector("#diagram-output svg");
    if (!svgElement) {
      showToast("info", "図が描画されていません");
      return;
    }

    const theme = getDiagramTheme();
    const isLightUi = document.body.classList.contains("ui-light");
    const bgColor = isLightUi ? "#ffffff" : "#0b0d14";

    const { svgData, width, height } = getSvgForExport(svgElement, theme);
    const exportScale = Math.max(2, Math.ceil(window.devicePixelRatio || 1));

    function makeCanvas() {
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      canvas.width = Math.max(1, Math.round(width * exportScale));
      canvas.height = Math.max(1, Math.round(height * exportScale));
      ctx.setTransform(exportScale, 0, 0, exportScale, 0, 0);
      ctx.fillStyle = bgColor;
      ctx.fillRect(0, 0, width, height);
      return { canvas, ctx };
    }

    function triggerPngDownload(canvas) {
      const link = document.createElement("a");
      link.download = "diagram.png";
      link.href = canvas.toDataURL("image/png");
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }

    // Fast path: rasterize via <img>. If canvas is tainted (e.g. external fonts), fall back to canvg.
    try {
      const { canvas, ctx } = makeCanvas();
      await rasterizeSvgWithImage(ctx, svgData, width, height);
      triggerPngDownload(canvas);
      return;
    } catch (e) {
      try {
        const { canvas, ctx } = makeCanvas();
        const canvg = getCanvg();
        if (!canvg) throw e;
        const v = await canvg.from(ctx, svgData, {
          ignoreAnimation: true,
          ignoreMouse: true,
          useCORS: true,
        });
        await v.render();
        triggerPngDownload(canvas);
        return;
      } catch (e2) {
        console.error("PNG export failed:", e2);
        showToast(
          "error",
          "PNG出力に失敗しました: " + (e2 && e2.message ? e2.message : e2)
        );
        return;
      }
    }
  }

  function getSvgForExport(svgElement, theme) {
    const clone = svgElement.cloneNode(true);
    clone.setAttribute("xmlns", "http://www.w3.org/2000/svg");

    // Force safe fonts (avoid external font loads -> tainted canvas)
    const style = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "style"
    );
    const defaultFont =
      "system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Hiragino Sans', 'Yu Gothic', 'Meiryo', Arial, sans-serif";
    const isDarkBg = theme === "dark";
    const textColor = isDarkBg ? "#e5e7eb" : "#111827";
    style.textContent =
      "*{font-family:" +
      defaultFont +
      " !important;}" +
      "text,tspan{fill:" +
      textColor +
      " !important; stroke:none !important; opacity:1 !important;}" +
      "foreignObject *{color:" +
      textColor +
      " !important; font-family:" +
      defaultFont +
      " !important;}";
    clone.insertBefore(style, clone.firstChild);

    // Inline computed styles for geometry (stroke/fill) so exported SVG doesn't depend on external CSS.
    inlineSvgGeometryStyles(svgElement, clone);
    inlineSvgTextStyles(svgElement, clone, textColor);
    bringTextToFront(clone);

    const vb =
      svgElement.viewBox && svgElement.viewBox.baseVal
        ? svgElement.viewBox.baseVal
        : null;
    let width = vb ? vb.width : 0;
    let height = vb ? vb.height : 0;
    if (!(width > 0 && height > 0)) {
      try {
        const bbox = svgElement.getBBox();
        width = bbox.width;
        height = bbox.height;
        if (!clone.getAttribute("viewBox"))
          clone.setAttribute(
            "viewBox",
            String(bbox.x) +
            " " +
            String(bbox.y) +
            " " +
            String(bbox.width) +
            " " +
            String(bbox.height)
          );
      } catch (_) { }
    }
    if (!(width > 0 && height > 0)) {
      width = 1200;
      height = 800;
      if (!clone.getAttribute("viewBox"))
        clone.setAttribute(
          "viewBox",
          "0 0 " + String(width) + " " + String(height)
        );
    }

    clone.setAttribute("width", String(width));
    clone.setAttribute("height", String(height));
    return {
      svgData: new XMLSerializer().serializeToString(clone),
      width,
      height,
    };
  }

  function inlineSvgGeometryStyles(srcSvg, dstSvg) {
    if (!srcSvg || !dstSvg) return;

    // Mermaid (and similar diagram generators) primarily use these geometry elements.
    const selector =
      "rect, circle, ellipse, path, polygon, polyline, line, use, marker";
    const srcNodes = srcSvg.querySelectorAll(selector);
    const dstNodes = dstSvg.querySelectorAll(selector);
    const len = Math.min(srcNodes.length, dstNodes.length);

    // Use inline styles with !important to override Mermaid's internal <style> rules
    // (which may rely on external CSS variables and break once serialized to a standalone SVG).
    const props = [
      "fill",
      "fill-opacity",
      "stroke",
      "stroke-opacity",
      "stroke-width",
      "stroke-dasharray",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "opacity",
    ];

    for (let i = 0; i < len; i++) {
      const src = srcNodes[i];
      const dst = dstNodes[i];
      const cs = window.getComputedStyle(src);
      if (!cs) continue;

      for (const prop of props) {
        const val = cs.getPropertyValue(prop);
        if (val == null) continue;
        const trimmed = String(val).trim();
        if (!trimmed || trimmed === "auto") continue;
        dst.setAttribute(prop, trimmed);
        if (dst.style && typeof dst.style.setProperty === "function") {
          dst.style.setProperty(prop, trimmed, "important");
        }
      }
    }
  }

  function inlineSvgTextStyles(srcSvg, dstSvg, fallbackTextColor) {
    if (!srcSvg || !dstSvg) return;
    const srcTexts = srcSvg.querySelectorAll("text,tspan");
    const dstTexts = dstSvg.querySelectorAll("text,tspan");
    const len = Math.min(srcTexts.length, dstTexts.length);
    const defaultFont =
      "system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Hiragino Sans', 'Yu Gothic', 'Meiryo', Arial, sans-serif";
    for (let i = 0; i < len; i++) {
      const src = srcTexts[i];
      const dst = dstTexts[i];
      const cs = window.getComputedStyle(src);
      if (!cs) continue;
      const fallbackFill = fallbackTextColor || "#e2e8f0";
      const map = {
        fill: cs.getPropertyValue("fill") || fallbackFill,
        "font-size": cs.getPropertyValue("font-size"),
        "font-family": defaultFont,
        "font-weight": cs.getPropertyValue("font-weight"),
        "font-style": cs.getPropertyValue("font-style"),
        "text-anchor": cs.getPropertyValue("text-anchor"),
        "dominant-baseline": cs.getPropertyValue("dominant-baseline"),
        stroke: cs.getPropertyValue("stroke"),
        "stroke-width": cs.getPropertyValue("stroke-width"),
      };
      for (const key in map) {
        const val = map[key];
        if (!val) continue;
        const trimmed = String(val).trim();
        if (!trimmed) continue;
        dst.setAttribute(key, trimmed);
        if (dst.style && typeof dst.style.setProperty === "function") {
          dst.style.setProperty(key, trimmed, "important");
        }
      }
    }
  }

  function bringTextToFront(svg) {
    if (!svg || !svg.querySelectorAll) return;
    const texts = svg.querySelectorAll("text, tspan");
    if (!texts.length) return;
    texts.forEach((el) => {
      const parent = el.parentNode;
      if (parent && parent.appendChild) parent.appendChild(el);
    });
  }

  function getCanvg() {
    const CanvgGlobal = window.Canvg || (window.canvg && window.canvg.Canvg);
    if (!CanvgGlobal) return null;
    if (typeof CanvgGlobal.from === "function") return CanvgGlobal;
    if (typeof CanvgGlobal.fromString === "function") {
      return {
        from: async (ctx, svg, opts) => CanvgGlobal.fromString(ctx, svg, opts),
      };
    }
    return null;
  }

  function rasterizeSvgWithImage(ctx, svgData, width, height) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.crossOrigin = "anonymous";
      const svgBlob = new Blob([svgData], {
        type: "image/svg+xml;charset=utf-8",
      });
      const url = URL.createObjectURL(svgBlob);
      img.onload = function () {
        try {
          ctx.drawImage(img, 0, 0, width, height);
          URL.revokeObjectURL(url);
          resolve();
        } catch (e) {
          URL.revokeObjectURL(url);
          reject(e);
        }
      };
      img.onerror = function (e) {
        URL.revokeObjectURL(url);
        reject(e);
      };
      img.src = url;
    });
  }
  function downloadFile(content, filename, type) {
    const blob = new Blob([content], { type: type });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  // --- History (User Properties) ---
  const HISTORY_PAGE_SIZE = 10;
  let historyNextOffset = 0;
  let historyHasMore = false;
  let historyOpCount = 0;
  function beginHistoryOp(messageKey, rowId = null) {
    historyOpCount++;
    setHistoryBusy(true, messageKey);
    if (rowId != null) setHistoryRowBusy(rowId, true, messageKey);
    return () => {
      if (rowId != null) setHistoryRowBusy(rowId, false);
      historyOpCount = Math.max(0, historyOpCount - 1);
      if (historyOpCount === 0) setHistoryBusy(false);
    };
  }
  function setHistoryBusy(busy, messageKey) {
    const status = document.getElementById("historyStatus");
    const statusText = document.getElementById("historyStatusText");
    const overlay = document.getElementById("historyOverlay");
    const overlayText = document.getElementById("historyOverlayText");
    const clearBtn = document.getElementById("clearHistoryBtn");
    const loadMoreBtn = document.getElementById("historyLoadMoreBtn");

    if (status) {
      status.classList.toggle("hidden", !busy);
      status.classList.toggle("flex", busy);
    }
    if (statusText)
      statusText.textContent = busy ? t(messageKey || "historyUpdating") : "";

    if (overlay) overlay.classList.toggle("hidden", !busy);
    if (overlayText)
      overlayText.textContent = busy ? t(messageKey || "historyUpdating") : "";

    if (clearBtn) clearBtn.disabled = !!busy;
    if (loadMoreBtn) loadMoreBtn.disabled = !!busy;
    if (clearBtn) clearBtn.classList.toggle("opacity-50", !!busy);
    if (loadMoreBtn) loadMoreBtn.classList.toggle("opacity-50", !!busy);
  }
  function setHistoryRowBusy(id, busy, messageKey) {
    const row = document.querySelector(
      '[data-history-id="' + CSS.escape(String(id)) + '"]'
    );
    if (!row) return;
    row.classList.toggle("opacity-60", !!busy);
    row.classList.toggle("pointer-events-none", !!busy);
    const spinner = row.querySelector("[data-history-spinner]");
    if (spinner) spinner.classList.toggle("hidden", !busy);
    if (spinner && messageKey) spinner.setAttribute("title", t(messageKey));
  }
  function renderHistorySkeleton(count = 4) {
    const list = document.getElementById("historyList");
    if (!list) return;
    list.innerHTML = Array.from({ length: count })
      .map(function () {
        return (
          '<div class="glass-panel rounded-xl p-3 flex items-start justify-between gap-3">' +
          '<div class="flex-1 min-w-0 grid gap-2">' +
          '<div class="skeleton h-4 rounded w-3/4"></div>' +
          '<div class="skeleton h-3 rounded w-1/2"></div>' +
          '<div class="skeleton h-3 rounded w-1/3"></div>' +
          "</div>" +
          '<div class="flex items-center gap-1 flex-none">' +
          '<div class="skeleton h-8 w-8 rounded"></div>' +
          "</div>" +
          "</div>"
        );
      })
      .join("");
  }

  function setHistoryLoadMoreVisible(visible) {
    const btn = document.getElementById("historyLoadMoreBtn");
    if (!btn) return;
    btn.classList.toggle("hidden", !visible);
  }

  function setHistoryLoadMoreDisabled(disabled) {
    const btn = document.getElementById("historyLoadMoreBtn");
    if (!btn) return;
    btn.disabled = !!disabled;
    btn.classList.toggle("opacity-50", !!disabled);
  }
  // --- API Key Management (Local Storage) ---
  const API_KEY_STORAGE_KEY = "diagram.userApiKey";

  function getApiKey() {
    return localStorage.getItem(API_KEY_STORAGE_KEY) || "";
  }

  function saveApiKey() {
    const input = document.getElementById("apiKeyInput");
    if (!input) return;
    const key = input.value.trim();
    if (!key) {
      showToast("error", "APIキーを入力してください");
      return;
    }
    localStorage.setItem(API_KEY_STORAGE_KEY, key);
    input.value = "";
    updateApiKeyStatusUI();
    showToast("success", "APIキーを保存しました（ブラウザに保存）");
  }

  function clearApiKey() {
    localStorage.removeItem(API_KEY_STORAGE_KEY);
    const input = document.getElementById("apiKeyInput");
    if (input) input.value = "";
    updateApiKeyStatusUI();
    showToast("info", "APIキーを削除しました");
  }

  function updateApiKeyStatusUI() {
    const key = getApiKey();
    const icon = document.getElementById("apiKeyStatusIcon");
    const text = document.getElementById("apiKeyStatusText");
    const input = document.getElementById("apiKeyInput");

    if (icon && text) {
      if (key) {
        icon.textContent = "lock";
        icon.className = "material-symbols-outlined text-sm text-green-400";
        text.textContent = "個人のAPIキーを使用中";
        text.className = "text-green-400 font-bold";
      } else {
        icon.textContent = "cloud";
        icon.className = "material-symbols-outlined text-sm text-amber-400";
        text.textContent = "共有キー（無料枠）を使用中";
        text.className = "ui-muted font-medium";
      }
    }
    if (input) {
      input.placeholder = key ? "（設定済み）" : "AIza...";
    }
  }

  // --- History Management (Local Storage) ---
  const HISTORY_STORAGE_KEY = "diagram.history.items";
  const HISTORY_LIMIT = 30;

  function saveHistoryManual() {
    applyEditsToMermaidCode({ rerender: false });
    pendingHistorySave = false;
    saveHistory({ reason: "manual" });
  }

  function getHistoryItemsLocal() {
    try {
      const raw = localStorage.getItem(HISTORY_STORAGE_KEY);
      const parsed = raw ? JSON.parse(raw) : [];
      return Array.isArray(parsed) ? parsed : [];
    } catch (e) { return []; }
  }

  function saveHistory(meta = {}) {
    const prompt = document.getElementById("userInput").value || "";
    const code = document.getElementById("mermaidCode").value || "";
    // Allow saving if there is an error, even if code is empty (e.g. API failure)
    if (!code.trim() && !(meta && meta.error)) {
      showToast("info", "保存するMermaidコードがありません");
      return;
    }

    const items = getHistoryItemsLocal();
    const newItem = {
      id: "loc_" + Date.now() + "_" + Math.random().toString(36).substring(2, 5),
      createdAt: Date.now(),
      prompt: prompt.slice(0, 2000),
      code: code.slice(0, 8000),
      diagramType: document.getElementById("diagramTypeSelect").value,
      model: "flash-lite",
      theme: getDiagramTheme(),
      fileName: currentFile && currentFile.filename ? currentFile.filename : null,
      meta,
    };

    items.unshift(newItem);
    if (items.length > HISTORY_LIMIT) {
      items.length = HISTORY_LIMIT;
    }

    try {
      localStorage.setItem(HISTORY_STORAGE_KEY, JSON.stringify(items));
      refreshHistory();
    } catch (e) {
      showToast("error", "履歴保存エラー: 容量オーバーの可能性があります");
    }
  }

  function refreshHistory() {
    const items = getHistoryItemsLocal();
    renderHistoryList(items);
    setHistoryLoadMoreVisible(false);
  }

  function loadMoreHistory() {
    // No-op for local
  }

  function renderHistoryList(items) {
    const list = document.getElementById("historyList");
    if (!list) return;
    list.innerHTML = "";

    if (!items.length) {
      const msg = typeof t === "function" ? t("historyEmpty") : "No history";
      list.innerHTML =
        '<div class="text-sm ui-muted border ui-border rounded-lg p-3">' +
        escapeHtml(msg) +
        "</div>";
      return;
    }
    appendHistoryList(items);
  }

  function appendHistoryList(items) {
    const list = document.getElementById("historyList");
    if (!list) return;

    const fragment = document.createDocumentFragment();

    for (const item of items || []) {
      const ts = item.createdAt ? new Date(item.createdAt) : null;
      const timeText = ts ? ts.toLocaleString() : "";
      const title =
        (item.prompt || item.diagramType || "diagram")
          .toString()
          .trim()
          .slice(0, 40) || "diagram";
      const subtitle = [item.diagramType, item.theme]
        .filter(Boolean)
        .join(" / ");

      const isError = item.meta && item.meta.error;
      const row = document.createElement("div");
      row.className =
        "glass-panel rounded-xl p-3 flex items-start justify-between gap-3" +
        (isError ? " ring-1 ring-red-500/30 bg-red-500/5" : "");
      row.dataset.historyId = String(item.id);

      const errorIcon = isError
        ? '<span class="material-symbols-outlined text-red-500 text-sm align-middle mr-1">error</span>'
        : "";

      row.innerHTML =
        '<button class="text-left flex-1 min-w-0 hover:opacity-90 transition" title="Restore">' +
        '<div class="text-sm font-semibold ui-text truncate ' +
        (isError ? "text-red-500" : "") +
        '">' +
        errorIcon +
        escapeHtml(title) +
        "</div>" +
        '<div class="text-xs ui-muted truncate">' +
        escapeHtml(subtitle) +
        "</div>" +
        '<div class="text-xs ui-muted truncate">' +
        escapeHtml(timeText) +
        "</div>" +
        "</button>" +
        '<div class="flex items-center gap-1 flex-none">' +
        (isError
          ? '<button class="ui-muted canvas-control transition p-2 rounded-lg text-red-400 hover:text-red-500 hover:bg-red-500/10" title="' +
          escapeHtml(t("copyErrorLog")) +
          '"><span class="material-symbols-outlined text-lg">bug_report</span></button>'
          : "") +
        '<button class="ui-muted canvas-control transition p-2 rounded-lg" title="Delete">' +
        '<span class="material-symbols-outlined text-lg">delete</span>' +
        "</button>" +
        "</div>";

      const btns = row.querySelectorAll("button");
      // 0: Restore, 1: CopyLog (if error) or Delete, 2: Delete (if error)
      const loadBtn = btns[0];
      let copyBtn = null;
      let deleteBtn = null;

      if (isError) {
        copyBtn = btns[1];
        deleteBtn = btns[2];
      } else {
        deleteBtn = btns[1];
      }

      loadBtn.addEventListener("click", () => loadHistory(item.id));
      if (copyBtn)
        copyBtn.addEventListener("click", (e) => copyErrorLog(e, item.id));
      deleteBtn.addEventListener("click", () => deleteHistory(item.id));

      fragment.appendChild(row);
    }
    list.appendChild(fragment);
  }

  function loadHistory(id) {
    const items = getHistoryItemsLocal();
    const item = items.find(x => x.id === id);
    if (!item) {
      showToast("error", "履歴が見つかりません");
      return;
    }

    document.getElementById("userInput").value = item.prompt || "";
    document.getElementById("mermaidCode").value = item.code || "";
    syncFlowOnlyControls(item.code || "");

    const diagTypeEl = document.getElementById("diagramTypeSelect");
    if (item.diagramType && diagTypeEl) diagTypeEl.value = item.diagramType;

    if (item.theme) {
      localStorage.setItem(DIAGRAM_THEME_KEY, normalizeDiagramTheme(item.theme));
    }

    pendingHistorySave = false;
    changeTheme();
    togglePanel(false);
  }

  function deleteHistory(id) {
    if (typeof confirmAsync === "function") {
      confirmAsync("この履歴を削除しますか？", "削除確認").then(ok => {
        if (!ok) return;
        _doDelete(id);
      });
    } else {
      if (confirm("この履歴を削除しますか？")) _doDelete(id);
    }
  }

  function _doDelete(id) {
    const items = getHistoryItemsLocal();
    const next = items.filter(x => x.id !== id);
    localStorage.setItem(HISTORY_STORAGE_KEY, JSON.stringify(next));
    refreshHistory();
  }

  function clearHistory() {
    if (typeof confirmAsync === "function") {
      confirmAsync("履歴をすべて削除しますか？", "全削除確認").then(ok => {
        if (!ok) return;
        _doClear();
      });
    } else {
      if (confirm("履歴をすべて削除しますか？")) _doClear();
    }
  }

  function _doClear() {
    localStorage.removeItem(HISTORY_STORAGE_KEY);
    refreshHistory();
    showToast("info", "履歴を全削除しました");
  }

  async function copyErrorLog(e, id) {
    if (e && typeof e.stopPropagation === "function") e.stopPropagation();
    const items = getHistoryItemsLocal();
    const item = items.find((x) => x.id === id);
    if (!item) {
      showToast("error", "履歴が見つかりません");
      return;
    }
    const logObj = {
      timestamp: new Date(item.createdAt).toISOString(),
      id: item.id,
      error: item.meta ? item.meta.error : "Unknown error",
      prompt: item.prompt,
      param_model: item.model,
      param_type: item.diagramType,
      param_theme: item.theme,
      code: item.code,
    };
    try {
      await copyTextToClipboard(JSON.stringify(logObj, null, 2));
      showToast("success", t("errorLogCopied"));
    } catch (err) {
      showToast("error", "Copy failed: " + err);
    }
  }

  function escapeHtml(str) {
    return String(str)
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#39;");
  }

  function applyEditsToMermaidCode(options) {
    var opts = options || {};
    var rerender = opts.rerender !== false;
    var edits = interactiveEdits.nodeLabels || {};
    var keys = Object.keys(edits);
    if (!keys.length) return false;

    var textarea = document.getElementById("mermaidCode");
    if (!textarea) return false;
    var code = textarea.value || "";
    var updated = applyNodeLabelEditsToMermaid(code, edits);
    textarea.value = updated;
    interactiveEdits.nodeLabels = Object.create(null);
    if (rerender) renderDiagram();
    return true;
  }

  function applyNodeLabelEditsToMermaid(code, edits) {
    if (!isFlowchartLike(code)) return code;
    var out = code;
    var keys = Object.keys(edits || {});
    for (var i = 0; i < keys.length; i++) {
      var id = keys[i];
      out = replaceFlowchartNodeLabel(out, id, edits[id]);
    }
    return out;
  }

  function replaceFlowchartNodeLabel(code, nodeId, newLabel) {
    var id = String(nodeId);
    var normalized = String(newLabel).split("\r").join("");
    var label = normalized.split("\n").join("\\n");
    var patterns = [
      { open: "((", close: "))" },
      { open: "[[", close: "]]" },
      { open: "[/", close: "/]" },
      { open: "[", close: "]" },
      { open: "(", close: ")" },
      { open: "{", close: "}" },
    ];

    var openTokens = [];
    for (var i = 0; i < patterns.length; i++) openTokens.push(patterns[i].open);
    var found = findFlowchartNodeDeclaration(code, id, openTokens);
    if (!found) {
      var quoted = JSON.stringify(label);
      var suffix = code && code.charAt(code.length - 1) === "\n" ? "" : "\n";
      return code + suffix + id + "[" + quoted + "]";
    }

    var openMatch = null;
    for (var j = 0; j < patterns.length; j++) {
      if (code.indexOf(patterns[j].open, found.afterId) === found.afterId) {
        openMatch = patterns[j];
        break;
      }
    }
    if (!openMatch) return code;

    var labelStart = found.afterId + openMatch.open.length;
    var labelEnd = code.indexOf(openMatch.close, labelStart);
    if (labelEnd === -1) return code;

    return code.slice(0, labelStart) + label + code.slice(labelEnd);
  }

  function findFlowchartNodeDeclaration(code, id, openTokens) {
    var src = String(code || "");
    var needle = String(id || "");
    if (!needle) return null;

    function isWordChar(ch) {
      return !!ch && /[A-Za-z0-9_]/.test(ch);
    }

    var pos = 0;
    while (true) {
      var start = src.indexOf(needle, pos);
      if (start < 0) break;

      var prev = start > 0 ? src.charAt(start - 1) : "";
      var next = src.charAt(start + needle.length);
      pos = start + needle.length;

      // Match whole identifier only.
      if (isWordChar(prev) || isWordChar(next)) continue;

      var afterId0 = start + needle.length;
      var rest = src.slice(afterId0);
      var m2 = /^\s*/.exec(rest);
      var ws = m2 ? m2[0].length : 0;
      var afterId = afterId0 + ws;

      var ok = false;
      for (var i = 0; i < openTokens.length; i++) {
        if (src.indexOf(openTokens[i], afterId) === afterId) {
          ok = true;
          break;
        }
      }
      if (!ok) continue;
      return { afterId: afterId };
    }
    return null;
  }
</script>
